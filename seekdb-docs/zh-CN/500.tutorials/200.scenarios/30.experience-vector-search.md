---

slug: /experience-vector-search
---

# 体验向量搜索

## 向量搜索介绍

在当今信息爆炸的时代，用户常需要从海量数据中迅速搜索所需信息。例如在线文献数据库、电商平台产品目录、以及不断增长的多媒体内容库，都需要高效的搜索系统来快速定位到用户感兴趣的内容。随着数据量不断激增，传统的基于关键字的搜索方法已经无法满足用户对于搜索精度和速度的需求，向量搜索技术能够很好地解决这些问题。向量搜索通过将文本、图片、音频等不同类型的数据编码为数学上的向量，并在向量空间中进行搜索。这种方法允许系统捕捉数据的深层次语义信息，从而提供更为准确和高效的搜索结果。

seekdb 提供了存储、索引、搜索 Embedding 向量数据的能力，支持将向量数据与其他数据一起存储。

seekdb 最高支持 16000 维的 Float 类型的稠密向量，支持稀疏向量，支持曼哈顿距离、欧式距离、内积、余弦距离等多种类型向量距离的计算，支持基于 HNSW/IVF 向量索引的创建，支持增量更新删除，同时增量更新删除操作不会影响召回率。

seekdb 向量搜索具备带有标量过滤的混合搜索能力。同时提供灵活的访问接口，不仅支持通过 MySQL 协议各种语言客户端使用 SQL 访问，也可以使用 Python SDK 访问。同时也完成了对 AI 应用开发框架 LlamaIndex、DB-GPT 及 AI 应用开发平台 Dify 的适配，更好的服务于 AI 应用开发。

本文就通过使用 SQL 快速进行向量搜索。

## 前提条件

* 请确保您已安装 seekdb。
* 已连接到 seekdb。

## 快速上手

1. 创建向量列和索引

    创建表时，可以使用 `VECTOR(dim)` 数据类型声明指定列为向量列及其维度。向量索引需要创建在向量列上，且至少需要提供 `type` 和 `distance` 两个参数。

    示例中创建向量列 `embedding`，向量数据维度为 `3`，并在 `embedding` 列上创建 HNSW 索引，指定距离算法为 L2。

    ```sql
    CREATE TABLE t1(
        id INT PRIMARY KEY, 
        doc VARCHAR(200),
        embedding VECTOR(3), 
        VECTOR INDEX idx1(embedding) WITH (distance=L2, type=hnsw)
        );
    ```

2. 写入向量数据

    为了模拟在向量搜索的场景，需要先构造一些向量数据，每行数据都包括对数据的描述和对应的向量。示例中假设 `'苹果'` 对应的向量为 `'[1.2,0.7,1.1]'`， `'胡萝卜'` 对应的向量为 `'[5.3,4.8,5.4]'` 等。
   
    ```sql
    INSERT INTO t1
    VALUES (1, '苹果', '[1.2,0.7,1.1]'),
            (2, '香蕉', '[0.6,1.2,0.8]'),
            (3, '橙子','[1.1,1.1,0.9]'),
            (4, '胡萝卜', '[5.3,4.8,5.4]'),
            (5, '菠菜', '[4.9,5.3,4.8]'),
            (6, '西红柿','[5.2,4.9,5.1]');
    ```

    为了方便展示，本例简化了向量的维度，仅使用了 3 维向量，且向量是人工生成的。在实际应用中，需要使用嵌入模型对真实的文本进行生成，维度会达到数百或上千维。

    可以通过查询表中的数据查看是否写入成功。

    ```sql
    SELECT * FROM t1;
    ```

    预期返回结果如下：

    ```shell
    +----+-----------+---------------+
    | id | doc       | embedding     |
    +----+-----------+---------------+
    |  1 | 苹果      | [1.2,0.7,1.1] |
    |  2 | 香蕉      | [0.6,1.2,0.8] |
    |  3 | 橙子      | [1.1,1.1,0.9] |
    |  4 | 胡萝卜    | [5.3,4.8,5.4] |
    |  5 | 菠菜      | [4.9,5.3,4.8] |
    |  6 | 西红柿    | [5.2,4.9,5.1] |
    +----+-----------+---------------+
    6 rows in set
    ```

3. 执行向量搜索

    进行向量搜索需要提供向量作为搜索条件。假设我们需要找到所有 `'水果'`，其对应的向量为 `[0.9, 1.0, 0.9]`，则对应 SQL 为：

    ```sql
    SELECT id, doc FROM t1
    ORDER BY l2_distance(embedding, '[0.9, 1.0, 0.9]')
    APPROXIMATE LIMIT 3;
    ```

    预期返回结果如下：

    ```shell
    +----+--------+
    | id | doc    |
    +----+--------+
    |  3 | 橙子   |
    |  2 | 香蕉   |
    |  1 | 苹果   |
    +----+--------+
    3 rows in set
    ```

## 精确搜索和近似搜索对比

### 执行精确搜索

精确搜索采用全量扫描策略，通过计算查询向量与数据集中所有向量的距离来执行精确搜索。这种方法能够保证搜索结果的完全准确性，但由于需要进行全量距离计算，搜索性能会随着数据规模的增长而显著下降。

在执行精确搜索时，系统会将查询向量 vₑ 与向量空间中的所有向量进行距离计算和比对。完成全量距离计算后，系统会选取距离最近的 k 个向量作为搜索结果返回。

#### 示例：欧几里得搜索

欧几里得搜索（Euclidean Similarity Search）用于搜索向量空间中与查询向量最接近的 top-k 个向量，这里使用欧几里得距离作为度量标准。下面是一个示例，展示如何使用精确搜索从表中搜索出与查询向量最接近的前 5 个向量：

```sql
-- 创建测试表
CREATE TABLE t1 (
    id INT PRIMARY KEY,
    c1 VECTOR(3)
);

-- 插入数据
INSERT INTO t1 VALUES 
(1, '[0.1, 0.2, 0.3]'),
(2, '[0.2, 0.3, 0.4]'),
(3, '[0.3, 0.4, 0.5]'),
(4, '[0.4, 0.5, 0.6]'),
(5, '[0.5, 0.6, 0.7]'),
(6, '[0.6, 0.7, 0.8]'),
(7, '[0.7, 0.8, 0.9]'),
(8, '[0.8, 0.9, 1.0]'),
(9, '[0.9, 1.0, 0.1]'),
(10, '[1.0, 0.1, 0.2]');

-- 执行精确搜索
SELECT c1
FROM t1
ORDER BY l2_distance(c1, '[0.1, 0.2, 0.3]') LIMIT 5;
```

返回结果如下：

```shell
+---------------+
| c1            |
+---------------+
| [0.1,0.2,0.3] |
| [0.2,0.3,0.4] |
| [0.3,0.4,0.5] |
| [0.4,0.5,0.6] |
| [0.5,0.6,0.7] |
+---------------+
5 rows in set
```

### 使用向量索引执行近似搜索

向量索引搜索采用近似（Approximate Nearest Neighbor，ANN）策略，通过预构建的索引结构来加速搜索过程。虽然不能保证 100% 的结果精确度，但能显著提升搜索性能，在实际应用中可以在精确度和性能之间取得良好的平衡。

#### 示例：HNSW 索引近似搜索

```sql
-- 随表创建 HNSW 向量索引
CREATE TABLE t2 (
    id INT PRIMARY KEY,
    vec VECTOR(3),
    VECTOR INDEX idx(vec) WITH (distance=l2, type=hnsw, lib=vsag)
);

-- 插入测试数据
INSERT INTO t2 VALUES 
(1, '[0.1, 0.2, 0.3]'),
(2, '[0.2, 0.3, 0.4]'),
(3, '[0.3, 0.4, 0.5]'),
(4, '[0.4, 0.5, 0.6]'),
(5, '[0.5, 0.6, 0.7]'),
(6, '[0.6, 0.7, 0.8]'),
(7, '[0.7, 0.8, 0.9]'),
(8, '[0.8, 0.9, 1.0]'),
(9, '[0.9, 1.0, 0.1]'),
(10, '[1.0, 0.1, 0.2]');

-- 执行近似搜索，返回最相似的 5 条数据
SELECT id, vec
FROM t2
ORDER BY l2_distance(vec, '[0.1, 0.2, 0.3]')
APPROXIMATE
LIMIT 5;
```

返回结果如下，由于数据量较小，与上文精确搜索结果一致：

```shell
+------+---------------+
| id   | vec           |
+------+---------------+
|    1 | [0.1,0.2,0.3] |
|    2 | [0.2,0.3,0.4] |
|    3 | [0.3,0.4,0.5] |
|    4 | [0.4,0.5,0.6] |
|    5 | [0.5,0.6,0.7] |
+------+---------------+
5 rows in set
```

### 对比总结

两种搜索方式的对比总结如下：

| 对比项 | 精确搜索 | 近似搜索 |
|--------|----------------|----------------|
| 执行方式 | 全表扫描（`TABLE FULL SCAN`）后排序 | 直接通过向量索引（`VECTOR INDEX SCAN`）搜索 |
| 性能特点 | 需要扫描全表数据并进行排序，性能随数据量增长显著下降 | 通过索引直接定位目标数据，性能稳定 |
| 结果准确性 | 100% 准确，保证返回真实的最近邻 | 近似准确，可能存在少量误差 |
| 适用场景 | 数据量小、对准确性要求高的场景 | 大规模数据集、对性能要求高的场景 |

## 更多操作

更多体验 seekdb 的 AI Native 特性以及尝试基于 seekdb 搭建 AI 应用的使用指导，参见：

* [体验全文索引](40.experience-full-text-indexing.md)
* [体验混合搜索](50.experience-hybrid-search.md)
* [体验 AI 函数服务](60.experience-ai-function.md)
* [体验语义索引](70.experience-hybrid-vector-index.md)
* [基于 seekdb 搭建知识库桌面应用](../../500.tutorials/100.create-ai-app-demo/100.build-kb-in-seekdb.md)
* [基于 seekdb 多模融合构建文旅小助手](../../500.tutorials/100.create-ai-app-demo/300.build-multi-model-application-based-on-oceanbase.md)
* [基于 seekdb 构建图搜图应用](../../500.tutorials/100.create-ai-app-demo/400.build-image-search-app-in-seekdb.md)

除了使用 SQL 进行操作之外，也支持通过 seekdb 提供的 Python SDK（pyseekdb）进行操作，使用方法参见 [通过 Python SDK 体验嵌入式](../../100.get-started/50.use-seekdb-with-sdk/25.using-seekdb-in-python-sdk.md)和 [pyseekdb 概述](../../450.reference/900.sdk/10.pyseekdb-sdk/10.pyseekdb-sdk-get-started.md)。