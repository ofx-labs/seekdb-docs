---
slug: /database-schema-overview
---

# 数据库模式设计概述

本文主要介绍 seekdb 中的数据库模式。

## 数据库 Database

在 seekdb 中，Database 或者说数据库可以认为是表和索引等对象的集合。

seekdb 部署完成后，会自动创建一个名为 `test` 的数据库，可以用于测试或者体验，但是在实际使用中建议您自行创建数据库。

## 表 Table

在 seekdb 中，表是最基础的数据存储单元。表包含了所有用户可以访问的数据，每个表由多行记录组成，而每行记录则包含多个列。每个表的设计和使用都需要依据业务需求进行合理规划，以确保系统的高效性和可扩展性。

### 表类型

seekdb 支持的表类型有分区表、复制表、主键表和无主键表、外部表等等。

* 分区表：seekdb 可以把普通的表的数据按照一定的规则划分到不同的区块内，将同一区块的数据物理上存储在一起。这种划分区块的表叫做分区表。seekdb 的基本分区策略包括范围（Range）分区、列表（List）分区和哈希（Hash）分区。
* 主键表和无主键表：有主键表即表中包含主键的表；表中未指定主键的表称为无主键表。
* 外部表：数据库中的表数据存放在数据库的存储空间中，而外表的数据存储在外部存储服务中。
* 堆表：堆组织表模式，主键用于唯一性约束，而查询则依赖于主表，当用户数据按时间排序时，能够更有效地利用 Skip Index 提高查询效率。

此外，根据数据的存储方式，按行存储还是按列存储，seekdb 还引入新维度的表类型：**列存表、行列混存表。**

* **列存表**：列存表将数据按列而非按行存储，能够显著提高分析型查询的性能，尤其适用于大数据量和频繁进行聚合分析的场景。详情请参见：[列存表架构](https://www.oceanbase.com/docs/common-oceanbase-database-cn-1000000002014001)。

* **行列混存表**：按行存储和按列存储的数据都分别存储了一份，系统会自动根据查询语句判断选择行存还是列存查询性能更优，适用于交易类业务和分析类业务兼顾的场景。

### 表更新模式

seekdb 支持建表时指定数据的写入和查询模式。建表时，通过 `CREATE TABLE` 语句中的参数 `merge_engine` 选择 **delete_insert 更新模式** 和 **partial_update 更新模式** ，这两种模式是针对不同业务场景设计的数据更新策略。

+ **delete_insert（全列更新模式）**

  以 **查询性能优先**，通过“Merge-On-Write”机制将 `UPDATE` 操作转化为全列的 `DELETE` 和 `INSERT` 记录，确保每行数据包含完整的列值。这种模式显著提升了复杂查询和批处理的效率（如分析型任务），但增量数据需要额外存储空间，适用于 **增量数据频繁且需要快速分析** 的场景。

+ **partial_update（部分更新模式）**

  仅记录修改的列的值，避免冗余存储。查询时需合并多份数据以获取最新值，性能相对较低，但更适合 **高频更新但查询需求低** 的场景（如 OLTP 类业务），或对存储成本敏感的环境。

| **特性类别** | **delete_insert 更新模式** | **partial_update 更新模式** |
| --- | --- | --- |
| **存储方式** | 每次更新在 SSTable 中写入两行（`DELETE`和`INSERT`），包含全列数据。 | 每次更新仅记录修改的列的值，存储空间更节省。 |
| **查询效率** | 查询时提前在 memtable/sstable 中计算下压过滤算子。<br/>若增量数据过滤结果不包含对基线数据更新，则可以分别批处理基线与增量数据；<br/>如果过滤结果包含对基线数据更新，合并增量/基线的记录获取最新值进行投影。 | 查询时需合并多个 Memtable/SSTable 的记录，以获取主键的最新值，可能影响性能。<br/> 适用于对存储成本敏感且更新操作频繁的场景。 |
| **适用场景** | 增量数据比例较高，需要频繁执行复杂查询或批处理分析的场景。    | 高频更新但查询需求较低的场景。   |

更多内容，参见 [创建表](https://www.oceanbase.com/docs/common-oceanbase-database-cn-1000000002015448)。

## 索引 Index

索引是提高查询性能的关键组件。seekdb 通过支持多种索引类型，为用户提供了灵活且高效的数据检索方式。以下是一些常见的索引类型及其应用场景：

* **局部索引**：局部索引是针对单一分区建立的索引，适用于需要进行数据局部查询的场景。当数据被严格划分为多个分区时，局部索引能够显著减少查询时的数据扫描范围，从而提高查询效率。
* **唯一索引**：唯一索引确保数据列中的每个值都是唯一的。通过在某些列上创建唯一索引，数据库能够有效防止数据重复，并加速查询过程。
* **非唯一索引**：非唯一索引与唯一索引不同，它不要求列中的所有值都必须唯一。主要用于加速数据查询，尤其在查找符合特定条件的多条记录时，能够显著提高检索效率。
* **全文索引**：seekdb 支持了兼容 MySQL 的全文搜索能力，通过预先处理文本内容，建立关键词索引，有效提升全文搜索效率。更多有关全文索引的详细信息，请参见 [全文索引](https://www.oceanbase.com/docs/common-oceanbase-database-cn-1000000002016782)。
* **JSON 多值索引**：seekdb 支持多值索引功能，这对于 JSON 文档和其他集合数据类型特别有用。利用这项功能可以在数组或集合上创建索引，从而提高基于 JSON 数组元素进行搜索的查询效率。更多有关多值索引的详细信息，请参见 [多值索引](https://www.oceanbase.com/docs/common-oceanbase-database-cn-1000000002015436)。
* **空间索引**：空间索引用于优化地理空间数据的查询效率，广泛应用于地理信息系统（GIS）和位置相关的服务。在这些应用中，空间索引可以快速检索地理坐标范围内的数据信息，为位置服务提供强有力的支持。
* **列存索引**：seekdb 支持创建表时指定表的存储格式为列存，索引和数据表一样都是一张表，所以也支持设置索引表中的数据以列存形式存储。列存索引依据列而非行进行存储，能够显著提升分析类查询的性能，特别是在处理大规模数据时，能够大幅缩短数据检索和分析的时间，从而实现实时分析。更多有关列存的详细信息，请参见 [列存](https://www.oceanbase.com/docs/common-oceanbase-database-cn-1000000002014001)。

更多关于索引的详细信息，参见[索引简介](https://www.oceanbase.com/docs/common-oceanbase-database-cn-1000000002016787)。

## 数据类型 Data type

在创建和使用表之前，需要根据业务需求合理规划表结构和数据类型。为确保数据存储的高效性和查询的优化，应遵循以下原则：

* **规范化表结构**：通过合理设计表结构，确保数据冗余最小化，提升查询效率。
* **选择合适的 SQL 数据类型**：为每个列选择最适合的 SQL 数据类型，以减少存储空间并提高查询速度。

常见的 SQL 数据类型包括：

* **基础数据类型**：如 `INT`、`VARCHAR`、`DATE` 等。
* **复杂数据类型**：如 `JSON`、`ARRAY`、`BITMAP` 等，适用于存储更复杂的数据结构。

详细的 SQL 数据类型描述，参见 [数据类型](https://www.oceanbase.com/docs/common-oceanbase-database-cn-1000000002017567)

## 视图 View

seekdb 支持普通视图和物化视图。

* 普通视图（Standard Views）：普通视图也叫非物化视图，是最常见的视图类型。它们仅仅存储定义视图的 SQL 查询，而不存储查询结果。
* 物化视图（Materialized Views）：物化视图与普通视图不同，它们在物理存储上保留了查询的结果。seekdb 支持异步物化视图，即基础表数据变动时，并不会立即更新物化视图，保证了基表 DML 操作的执行性能。参见 [物化视图](https://www.oceanbase.com/docs/common-oceanbase-database-cn-1000000002017308) 。