---
slug: /create-table
---

# CREATE TABLE

## 描述

该语句用来在数据库中创建一张新表。

## 语法

```sql
CREATE [hint_options] [TEMPORARY] TABLE [IF NOT EXISTS] table_name
      (table_definition_list) [table_option_list] [partition_option] [[MERGE_ENGINE = {delete_insert | partial_update}] table_column_group_option] [IGNORE | REPLACE] [AS] select;

CREATE TABLE [TEMPORARY] [IF NOT EXISTS] table_name
      LIKE table_name;

table_definition_list:
    table_definition [, table_definition ...]

table_definition:
      column_definition_list
    | [CONSTRAINT [constraint_name]] PRIMARY KEY index_desc
    | [CONSTRAINT [constraint_name]] UNIQUE {INDEX | KEY}
            [index_name] index_desc
    | [CONSTRAINT [constraint_name]] FOREIGN KEY
            [index_name] index_desc
            REFERENCES reference_definition
            [match_action][opt_reference_option_list]
    | [FULLTEXT] {INDEX | KEY} [index_name] [index_type] (key_part,...) [WITH PARSER tokenizer_option] [PARSER_PROPERTIES[=](parser_properties_list)]
      [index_option_list] [index_column_group_option]
    | index_json_clause
    | [CONSTRAINT [constraint_name]] CHECK(expression) constranit_state

column_definition_list:
    column_definition [, column_definition ...]

column_definition:
     column_name data_type
         [DEFAULT const_value] [AUTO_INCREMENT]
         [NULL | NOT NULL] [[PRIMARY] KEY] [UNIQUE [KEY]] [COMMENT string_value] [SKIP_INDEX(skip_index_option_list)]
   | column_name data_type
         [GENERATED ALWAYS] AS (expr) [VIRTUAL | STORED]
         [opt_generated_column_attribute]

skip_index_option_list:
    skip_index_option [,skip_index_option ...]

skip_index_option:
    MIN_MAX
    | SUM

index_desc:
   (column_desc_list) [index_type] [index_option_list]

match_action:
   MATCH {SIMPLE | FULL | PARTIAL}

opt_reference_option_list:
   reference_option [,reference_option ...]

reference_option:
   ON {DELETE | UPDATE} {RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT}

tokenizer_option:
    SPACE
    | NGRAM
    | BENG
    | IK
    | NGRAM2

parser_properties_list:
    parser_properties, [parser_properties]

parser_properties:
    min_token_size = int_value
    | max_token_size = int_value
    | ngram_token_size = int_value
    | ik_mode = 'char_value'
    | min_ngram_size = int_value
    | max_ngram_size = int_value

key_part:
    {index_col_name [(length)] | (expr)} [ASC | DESC]

index_type:
    USING BTREE

index_option_list:
    index_option [ index_option ...]

index_option:
      [GLOBAL | LOCAL]
    | block_size
    | compression
    | STORING(column_name_list)
    | COMMENT string_value

table_option_list:
    table_option [ table_option ...]

table_option:
      [DEFAULT] {CHARSET | CHARACTER SET} [=] charset_name
    | [DEFAULT] COLLATE [=] collation_name
    | block_size
    | lob_inrow_threshold [=] num
    | compression
    | AUTO_INCREMENT [=] INT_VALUE
    | COMMENT string_value
    | ROW_FORMAT [=] REDUNDANT|COMPACT|DYNAMIC|COMPRESSED|DEFAULT
    | PCTFREE [=] num
    | parallel_clause
    | TABLE_MODE [=] 'table_mode_value'
    | auto_increment_cache_size [=] INT_VALUE
    | READ {ONLY | WRITE}
    | ORGANIZATION [=] {INDEX | HEAP}
    | enable_macro_block_bloom_filter [=] {True | False}
    | DYNAMIC_PARTITION_POLICY [=] (dynamic_partition_policy_list)
    | SEMISTRUCT_ENCODING_TYPE [=] 'encoding'

parallel_clause:
    {NOPARALLEL | PARALLEL integer}

table_mode_value:
    NORMAL
    | QUEUING
    | MODERATE
    | SUPER
    | EXTREME

dynamic_partition_policy_list:
    dynamic_partition_policy_option [, dynamic_partition_policy_option ...]

dynamic_partition_policy_option:
    ENABLE = {true | false}
    | TIME_UNIT = {'hour' | 'day' | 'week' | 'month' | 'year'}
    | PRECREATE_TIME = {'-1' | '0' | 'n {hour | day | week | month | year}'}
    | EXPIRE_TIME = {'-1' | '0' | 'n {hour | day | week | month | year}'}
    | TIME_ZONE = {'default' | 'time_zone'}
    | BIGINT_PRECISION = {'none' | 'us' | 'ms' | 's'}

partition_option:
      PARTITION BY HASH(expression)
      [subpartition_option] PARTITIONS partition_count
    | PARTITION BY KEY([column_name_list])
      [subpartition_option] PARTITIONS partition_count
    | PARTITION BY RANGE {(expression) | COLUMNS (column_name_list)}
      [subpartition_option] (range_partition_list)
    | PARTITION BY LIST {(expression) | COLUMNS (column_name_list)}
      [subpartition_option] PARTITIONS partition_count
    | PARTITION BY RANGE [COLUMNS]([column_name_list]) [SIZE('size_value')] (range_partition_list)

subpartition_option:
      SUBPARTITION BY HASH(expression)
      SUBPARTITIONS subpartition_count
    | SUBPARTITION BY KEY(column_name_list)
      SUBPARTITIONS subpartition_count
    | SUBPARTITION BY RANGE {(expression) | COLUMNS (column_name_list)}
      (range_subpartition_list)
    | SUBPARTITION BY LIST(expression)

range_partition_list:
    range_partition [, range_partition ...]

range_partition:
    PARTITION partition_name
    VALUES LESS THAN {(expression_list) | MAXVALUE}

range_subpartition_list:
    range_subpartition [, range_subpartition ...]

range_subpartition:
    SUBPARTITION subpartition_name
    VALUES LESS THAN {(expression_list) | MAXVALUE}

expression_list:
    expression [, expression ...]

column_name_list:
    column_name [, column_name ...]

partition_name_list:
    partition_name [, partition_name ...]

partition_count | subpartition_count:
    INT_VALUE

table_column_group_option/index_column_group_option:
      WITH COLUMN GROUP(all columns)
    | WITH COLUMN GROUP(each column)
    | WITH COLUMN GROUP(all columns, each column)

index_json_clause:
    [UNIQUE] INDEX idx_json_name((CAST(json_column_name->'$.json_field_name' AS UNSIGNED ARRAY)))
    | INDEX idx_json_name(column_name, [column_name, ...] (CAST(json_column_name->'$.json_field_name' AS CHAR(n) ARRAY)))
```

## 参数说明

|   **参数**   |        **描述**        |
|------------------------------------------------------|-----------------------------------|
| hint_options | 为可选项，指定 Hint 选项。支持手动指定旁路导入 Hint，包括 APPEND、DIRECT、NO_DIRECT。对应的 Hint 格式为 <code>/*+ [APPEND \| DIRECT(need_sort,max_error,load_type)] parallel(N) \|NO_DIRECT */</code>，有关 CREATE TABLE AS SELECT 语句旁路导入数据的内容，参见 [全量旁路导入](https://www.oceanbase.com/docs/common-oceanbase-database-cn-1000000002012783) 中的**使用 CREATE TABLE AS SELECT 语句旁路导入数据**章节。 |
| TEMPORARY |为可选项，表示将该表创建为临时表。 |
| IF NOT EXISTS | 如果指定 `IF NOT EXISTS`，即使待创建的表已存在，也不会报错；如果不指定且待创建的表已存在，则系统会报错。 |
| IGNORE \| REPLACE | 可选项，使用 `CREATE TABLE ... SELECT` 语句时指示如何处理重复唯一键值的行。当有重复唯一键值的行时，如果不指定 <code>IGNORE</code> 或者 <code>REPLACE</code> 将会报错。<ul><li><code>IGNORE</code>：如果新表中的唯一键值与复制的数据中的某行发生冲突，那么该冲突行将被忽略，不会被复制到新表中。即 <code>IGNORE</code> 选项会跳过重复的数据，只复制那些不会造成唯一键冲突的行。</li><li><code>REPLACE</code>：在遇到唯一键值重复的数据行，原新表中的行将被替换为新复制的数据中的行。</li></ul>|
| PRIMARY KEY                                          | 为创建的表指定主键。如果不指定，则使用隐藏主键。seekdb 支持修改表的主键或通过 `ALTER TABLE` 语句为表添加主键，参见 [ALTER TABLE](1600.alter-table.md)。     |
| FOREIGN KEY                                          | 为创建的表指定外键。如果不指定外键名，则会使用表名 + `OBFK` + 创建时间命名。（例如，在 2021 年 8 月 1 日 00:00:00 为 `t1` 表创建的外键名称为 `t1_OBFK_1627747200000000`）。外键允许跨表交叉引用相关数据，当 `UPDATE` 或 `DELETE` 操作影响与子表相匹配行的父表中键值时，其结果取决于 `ON UPDATE` 和 `ON DELETE` 子句的引用操作：<ul><li>`CASCADE`：表示从父表中删除或更新行，并自动删除或更新子表中匹配的行。</li><li>`SET NULL`：表示从父表中删除或更新行，并将子表中的外键列设置为 `NULL`。</li><li>`RESTRICT`：表示拒绝对父表的删除或更新操作。</li><li>`NO ACTION`：指定延迟检查。</li></ul>此外还支持 `SET DEFAULT` 操作。  |
| FULLTEXT | 可选项，指定创建全文索引。有关创建全文索引的详细信息，参见 [创建索引](https://www.oceanbase.com/docs/common-oceanbase-database-cn-1000000002015436) 中的 **创建全文索引** 章节。<br/>**注意：**只支持创建局部全文索引。 |
| WITH PARSER tokenizer_option                 | 可选项，指定全文索引的分词器。详细介绍可参见下文 [tokenizer_option](#tokenizer_option)。|
| PARSER_PROPERTIES\[=\](parser_properties_list) | 可选项，指定分词器的属性。详细介绍可参见下文 [parser_properties](#parser_properties)。 |
| KEY \| INDEX                                         | 为创建的表指定键或索引。如果不指定索引名，则会使用索引引用的第一列作为索引名，如果命名存在重复，则会使用下划线（_）+ 序号的方式命名。（例如，使用 `c1` 列创建的索引如果命名重复，则会将索引命名为 `c1_2`。） 您可以通过 `SHOW INDEX` 语句查看表上的索引。    |
| key_part        | 创建（函数）索引。 |
| index_col_name  | 指定索引的列名，每个列名后都支持 ASC（升序），不支持 DESC（降序）。默认为升序。建立索引的排序方式为：首先以 `index_col_name` 中第一个列的值排序；该列值相同的记录，按下一列名的值排序；以此类推。 |
| expr            | 表示合法的函数索引表达式，且允许是布尔表达式，例如 `c1=c1`。 <br/>**注意：**seekdb 当前版本禁止创建生成列上的函数索引。     |
| ROW_FORMAT                                           | 指定表是否开启 Encoding 存储格式。 <ul><li> `redundant`：不开启 Encoding 存储格式。   </li><li> `compact`：不开启 Encoding 存储格式。</li><li> `dynamic`：Encoding 存储格式。   </li><li> `compressed`：Encoding 存储格式。</li>   <li> `default`：等价 `dynamic` 模式。</li></ul>    |
| \[GENERATED ALWAYS\] AS (expr) \[VIRTUAL \| STORED\] | 创建生成列，`expr` 为用于计算列值的表达式。 <ul><li> `VIRTUAL`：列值不会被存储，而是在读取行时，在任何 `BEFORE` 触发器之后立即计算。虚拟列不占用存储空间。</li>   <li> `STORED`：在插入或更新行时评估和存储列值。存储列确实需要存储空间并且可以被索引。</li></ul>    |
| BLOCK_SIZE                                           | 指定表的微块大小。  |
| lob_inrow_threshold                                  | 用于配置 `LOB` 字段 `INROW` 阈值，当某个 `LOB` 字段数据大小超过该阈值时，超过部分会转为`OUTROW` 存储在 LOB Meta 表中，默认值由变量 `ob_default_lob_inrow_threshold` 控制。|
| COMPRESSION                                          | 指定表的压缩算法，取值如下： <ul><li> `none`：不使用压缩算法。</li>   <li> `lz4_1.0`: 使用 `lz4` 压缩算法。</li>   <li> `zstd_1.0`: 使用 `zstd` 压缩算法。</li>  <li> `snappy_1.0`: 使用 `snappy` 压缩算法。</li> </ul>    |
| CHARSET \| CHARACTER SET                             | 指定表中列的默认字符集，可使用的字符集请参见 [字符集](../100.basic-elements/300.character-set-and-collation/200.character-set.md)。    |
| COLLATE                                              | 指定表中列的默认字符序，可使用的字符序请参见 [字符序](../100.basic-elements/300.character-set-and-collation/300.collation.md)。  |
| AUTO_INCREMENT                                       | 指定表中自增列的初始值。seekdb 支持使用自增列作为分区键。  |
| COMMENT                                              | 注释。不区分大小写。|
| PCTFREE                                              | 指定宏块保留空间百分比。   |
| parallel_clause                                      | 指定表级别的并行度： <ul><li> `NOPARALLEL`：并行度为 `1`，默认配置 </li>  <li> `PARALLEL integer`：指定并行度，`integer` 取值大于等于 `1`。 </li></ul>    |
| CHECK                                                | 限制列中的值的范围。 <ul><li> 如果对单个列定义 `CHECK` 约束，那么该列级约束可以写到列定义中，并且可以指定名称。</li>   <li> 如果对一个表定义 `CHECK` 约束，那么此约束会应用于表中多个列，且允许出现在列的定义前。在删除表时，表中创建的 `CHECK` 约束也会一起被删除。</li></ul> 可以通过如下方式查看约束信息： <ul><li> 使用 `SHOW CREATE TABLE` 命令 </li>  <li> 查看 `information_schema.TABLE_CONSTRAINTS` 视图 </li>  <li> 查看 `information_schema.CHECK_CONSTRAINTS` 视图  </li> </ul>    |
| constraint_name                                      | 约束名称，最多包含 64 个字符。 <ul><li> 约束名称的开头结尾中间都允许有空格，但需要用"\`"标识名称的开头和结尾。   </li><li> 约束名称可以包含特殊字符"$"。   </li><li> 如果约束名称为保留字，需要用"\`"标识，否则会报错。   </li><li> 在同一 Database 下不允许 `CHECK` 约束的名称重复。</li></ul>    |
| expression                                           | 约束表达式。 <ul><li> `expression` 不允许为空。   </li><li> `expression` 结果不能为非布尔类型。 </li> <li> `expression` 不能包含不存在的列。 </li></ul>   |
| MERGE_ENGINE = \{delete_insert \| partial_update\} | 可选项，用于指定表的更新模型，取值如下：<ul><li>`partial_update`：默认值，表示采用现有的更新模式不变。</li><li>`delete_insert`: 表示采用 `merge on write` 的方式，将 `update` 转为 `delete` 和 `insert`，并且写全列。</li></ul> <br />说明 <ul><li>参数 <code>MERGE_ENGINE</code> 在创建表时指定之后，其配置值将不可修改。</li><li>对于 seekdb 支持 <code>MERGE_ENGINE</code> 参数。</li></ul>|
| table_column_group_option/index_column_group_option | 指定表或索引的列存选项。具体解释如下：<ul><li><code>WITH COLUMN GROUP(all columns, each column)</code>：指定创建行存列存冗余的表或索引。</li><li><code>WITH COLUMN GROUP(all columns)</code>：指定添加行存表或索引。</li><li><code>WITH COLUMN GROUP(each column)</code>：指定创建列存表或索引。</li></ul>|
| SKIP_INDEX | 标识列的 Skip Index 属性。 取值如下：<ul><li><code>MIN_MAX</code>：是 Skip Index 中最通用的聚合数据类型，它会在索引节点粒度下存储被索引列的最大值、最小值和 Null Count。这种类型的数据可以加速下推的 Filter 和 `MIN/MAX` 聚合的下推。</li><li> <code>SUM</code>：用于加速数值类型的 `SUM` 聚合的下推。</li></ul> <br />注意 <ul><li>JSON 和空间数据类型的列禁止创建 Skip Index。</li><li>生成列禁止创建 Skip Index。</li></ul>|
| index_json_clause | 指定创建多值索引子句。更多多值索引信息，参见 [创建索引](https://www.oceanbase.com/docs/common-oceanbase-database-cn-1000000002015436) 下 **创建多值索引** 章节。<br />注意 多值索引功能目前处于实验阶段，不推荐在生产环境中使用，以免影响系统稳定性。|
| json_column_name  | 指定表 `JSON` 数据类型的列名称。|
| idx_json_name     | 指定待创建的多值索引的索引名。|
| json_field_name   | Json 列中需要创建索引的字段名称。|
| TABLE_MODE        | 可选项，用于指定合并触发阈值与合并策略，即控制数据转储后的合并行为。取值的详细介绍可参见下文 [table_mode_value](#table_mode_value)。|
| auto_increment_cache_size | 可选项，用于设置缓存的自增值个数。该参数默认值为 0，表示该项未进行配置，系统将采用配置项（[auto_increment_cache_size](https://www.oceanbase.com/docs/common-oceanbase-database-cn-1000000002016007)）作为自增列的缓存大小设置。|
| READ \{ONLY \| WRITE\} | 指定表的读写权限。具体如下：<ul><li>`READ ONLY`：表示表只能被读取，不能被修改或删除。<br />注意 表级别的 <code>READ ONLY</code> 参数对具有 <code>SUPER</code> 权限的用户不生效，只对普通用户生效。</li><li>`READ WRITE`：默认值，表示表可以被读取、修改和删除。</li></ul>|
| ORGANIZATION [=] \{INDEX \| HEAP\} | 指定表中数据行的存储顺序，即指定表组织模式。取值如下：<ul><li>`INDEX`：表示索引组织表。</li><li>`HEAP`：表示堆组织表。</li></ul> 如果不指定 `ORGANIZATION` 选项，则该选项取值与配置项 [default_table_organization](https://www.oceanbase.com/docs/common-oceanbase-database-cn-1000000002502221) 的值相同。<br />说明seekdb 中 <code>CREATE TABLE</code> 语句支持 <code>ORGANIZATION</code> 选项。|
| enable_macro_block_bloom_filter [=] \{True \| False\} |用于指定是否持久化宏块级别 bloom filter。取值如下：<ul><li><code>True</code>：开启持久化宏块级别 bloom filter。</li><li><code>False</code>：关闭持久化宏块级别 bloom filter。</li></ul> <br />说明 seekdb 中 <code>CREATE TABLE</code> 语句支持 <code>enable_macro_block_bloom_filter</code> 选项。|
| DYNAMIC_PARTITION_POLICY \[=\] \(dynamic_partition_policy_list\) | 指定表的动态分区管理属性，实现分区的自动创建和删除。`dynamic_partition_policy_list` 动态分区策略的可配置参数列表，各参数用英文逗号分隔，详细介绍可参见下文 [dynamic_partition_policy_option](#dynamic_partition_policy_option)。<br />说明 seekdb 支持指定表的动态分区管理属性。|
| PARTITION BY RANGE \[COLUMNS\]\(\[column_name_list\]\) \[SIZE\('size_value'\)\] | 用于指定创建自动分区表。详细介绍可参见 [自动分区分裂](https://www.oceanbase.com/docs/common-oceanbase-database-cn-1000000002016858) 中的创建表时的自动分区语法。|
| SEMISTRUCT_ENCODING_TYPE | 可选项，用于指定半结构化编码类型。具体如下：<ul><li>`''`，表示不启用半结构化编码。</li><li>`'encoding'`，表示启用半结构化编码。</li></ul>功能使用说明可参见[使用半结构化编码](../100.basic-elements/100.data-type/800.json-formatted-data-type/200.create-a-json-value-of-syntax.md)。|

### table_mode_value

:::info

在以下列出的 `TABLE_MODE` 模式中，除了 `NORMAL` 模式之外，所有模式都代表 `QUEUING` 表。这种 `QUEUING` 表是最基本的表类型，并且随后列出的几种模式（除了 NORMAL 模式）代表了使用更加积极的合并策略。

:::

* `NORMAL`：默认值，表示正常。在该模式下，数据转储后触发合并的概率极低。
* `QUEUING`：在该模式下，数据转储后触发合并的概率低。
* `MODERATE`：表示适度。在该模式下，数据转储后触发合并的概率为中等。
* `SUPER`：表示超级。在该模式下，数据转储后触发合并的概率高。
* `EXTREME`：表示极端。在该模式下，转储后触发合并的概率较高。

更多有关合并的信息，请参见 [自适应合并](https://www.oceanbase.com/docs/common-oceanbase-database-cn-1000000002013691)。

### tokenizer_option

* `SPACE`：默认值，表示按空格进行分词。可以指定以下属性：

  |        属性      | 取值范围 |
  |------------------|---------|
  | min_token_size   | [1, 16] |
  | max_token_size   | [10, 84]|

* `NGRAM`：表示基于 N-Gram（中文）的分词方式。可以指定以下属性：

  |        属性      | 取值范围 |
  |------------------|---------|
  | ngram_token_size | [1, 10] |

* `NGRAM2`：表示将文本拆成 `min_ngram_size`～`max_ngram_size` 范围的连续字符。可以指定以下属性：

  |        属性      | 取值范围 |
  |------------------|---------|
  | min_ngram_size   | [1, 16] |
  | max_ngram_size   | [1, 16] |

* `BENG`：基于 Beng （基础英文）的分词方式。可以指定以下属性：

  |        属性      | 取值范围 |
  |------------------|---------|
  | min_token_size   | [1, 16] |
  | max_token_size   | [10, 84]|

* `IK`：表示基于 IK（中文）的分词方式。当前仅支持 `utf-8` 字符集。可以指定以下属性：

  |        属性      | 取值范围 |
  |------------------|---------|
  | ik_mode          | <ul><li>`smart`</li><li>`max_word`</li></ul>|

### parser_properties

* `min_token_size`：表示最小分词长度，默认值为 3，取值范围是 1 到 16。

* `max_token_size`：表示最大分词长度，默认值为 84，取值范围是 10 到 84。

* `ngram_token_size`：表示 `NGRAM` 的分词长度，只有 `NGRAM` 分词器有效，默认值为 2，取值范围是 1 到 10。

* `ik_mode`: 表示 `IK` 分词器的分词模式。取值如下：

  * `smart`：默认值，表示词典中的词汇会被用来提高分词的准确性，词典中的词汇边界会被优先考虑，从而可能减少不必要的扩展。
  * `max_word`：表示在词典中定义的词汇会被识别出来，但不会影响分词的最大化扩展。即使词典中有定义，`max_word` 模式仍然会尝试将文本切分成更多的词汇。

* `min_ngram_size`：表示最小分词长度，的取值范围为[1,16]。

* `max_ngram_size`: 表示最大分词长度，的取值范围为[1,16]。

**示例如下：**

```sql
CREATE TABLE tbl1 (col1 VARCHAR(200), col2 TEXT,
    FULLTEXT INDEX fidx(col2) WITH PARSER ik PARSER_PROPERTIES=(ik_mode='max_word'));
```

### dynamic_partition_policy_option

* `ENABLE = {true | false}`：可选项，表示是否启用动态分区管理。可修改，取值如下：

  * `true`：默认值，表示启用动态分区管理。
  * `false`：表示禁用动态分区管理。

* `TIME_UNIT = {'hour' | 'day' | 'week' | 'month' | 'year'}`：必选项，表示分区的时间单位，即自动创建分区边界的间隔。不可修改，取值如下：

  * `hour`：按小时划分分区。
  * `day`：按天划分分区。
  * `week`：按周（星期）划分分区。
  * `month`：按月划分分区。
  * `year`：按年划分分区。

* `PRECREATE_TIME = {'-1' | '0' | 'n {hour | day | week | month | year}'}`：可选项，表示预创建时间。调度一次动态分区管理，会预创建分区使得 **最大分区上界 > now() + precreate_time**。可修改，取值如下：

  * `-1`：默认值，表示不预创建分区。
  * `0`：表示仅预创建当前分区。
  * `n {hour | day | week | month | year}`：表示预创建对应时间跨度的分区。例如，`3 hour` 表示预创建 3 小时内的分区。

  :::info

  * 需要预创建多个分区时，分区边界的间隔为 `TIME_UNIT`。

  * 首个预创建的分区边界为现存最大分区边界按 `TIME_UNIT` 向上取整。

  :::

* `EXPIRE_TIME = {'-1' | '0' | 'n {hour | day | week | month | year}'}`：可选项，表示分区过期时间。调度一次动态分区管理，会删除所有 **分区上界 < now() - expire_time** 的过期分区。可修改，取值如下：

  * `-1`：默认值，表示分区永不过期。
  * `0`：表示除当前分区外，之前的所有分区均过期。
  * `n {hour | day | week | month | year}`：表示分区过期时间。例如，`1 day` 表示分区过期时间为 1 天。

* `TIME_ZONE = {'default' | 'time_zone'}`：可选项，表示判断当前时间与时间类型（`date`、`datetime`、`year` 类型）分区键大小时，依赖的时区信息。不可修改，取值如下：

  * `default`：默认值，表示不额外配置时区，使用实例时区。除上述类型外，其他类型 `time_zone` 字段必须为 `default`。
  * `time_zone`：表示自定义时区偏移值。例如，`+8:00` 等时区偏移值。

* `BIGINT_PRECISION = {'none' | 'us' | 'ms' | 's'}`：可选项，表示 `bigint` 类型分区键的时间戳精度。不可修改，取值如下：

  * `none`：默认值，表示无精度（分区键不为 `bigint` 类型）。
  * `us`：微秒精度。
  * `ms`：毫秒精度。
  * `s`：秒精度。

更多有关创建动态分区表的信息，参见 [创建动态分区表](https://www.oceanbase.com/docs/common-oceanbase-database-cn-1000000002978412)。

**示例如下：**

```sql
CREATE TABLE tbl2 (col1 INT, col2 DATETIME)
    DYNAMIC_PARTITION_POLICY(
        ENABLE = true,
        TIME_UNIT = 'hour',
        PRECREATE_TIME = '3 hour',
        EXPIRE_TIME = '1 day',
        TIME_ZONE = '+8:00',
        BIGINT_PRECISION = 'none')
    PARTITION BY RANGE COLUMNS (col2)(
        PARTITION P0 VALUES LESS THAN ('2024-11-11 13:30:00')
        );
```

## 示例

* 创建数据库表。

  ```sql
  CREATE TABLE tbl1 (c1 INT PRIMARY KEY, c2 VARCHAR(50));
  Query OK, 0 rows affected (0.061 sec)
  ```

* 创建带索引的表。

  ```sql
  CREATE TABLE tbl2 (c1 INT PRIMARY KEY, c2 INT, c3 INT, INDEX i1 (c2));
  Query OK, 0 rows affected (0.063 sec)
  ```

* 创建带有函数索引的表 `tbl3`。

  ```shell
  CREATE TABLE tbl3 (c1 INT, c2 INT, INDEX i1 ((c1+1)), UNIQUE KEY ((c1+c2)));
  Query OK, 0 rows affected (0.440 sec)

  SHOW CREATE TABLE tbl3;
  +-------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
  | Table | Create Table                                                                                                                                                                                                                                                                                                                                                                     |
  +-------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
  | tbl3    | CREATE TABLE `tbl3` (
  `c1` int(11) DEFAULT NULL,
  `c2` int(11) DEFAULT NULL,
  UNIQUE KEY `functional_index` ((`c1` + `c2`)) BLOCK_SIZE 16384 LOCAL,
  KEY `i1` ((`c1` + 1)) BLOCK_SIZE 16384 LOCAL
  ) DEFAULT CHARSET = utf8mb4 ROW_FORMAT = DYNAMIC COMPRESSION = 'zstd_1.3.8' REPLICA_NUM = 2 BLOCK_SIZE = 16384 USE_BLOOM_FILTER = FALSE TABLET_SIZE = 134217728 PCTFREE = 0 |
  +-------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
  ```

* 创建 Hash 分区，分区数为 `8` 的表。

  ```sql
  CREATE TABLE tbl4 (c1 INT PRIMARY KEY, c2 INT) PARTITION BY HASH(c1) PARTITIONS 8;
  Query OK, 0 rows affected (0.024 sec)
  ```

* 创建一级分区为 Range 分区，二级分区为 Key 分区的表。

  ```sql
  CREATE TABLE tbl5 (c1 INT, c2 INT, c3 INT) PARTITION BY RANGE(c1)
       SUBPARTITION BY KEY(c2, c3) SUBPARTITIONS 5
       (PARTITION p0 VALUES LESS THAN(0), PARTITION p1 VALUES LESS THAN(100));
  Query OK, 0 rows affected (0.054 sec)
  ```

* 创建一列为 `gbk`, 一列为 `utf8` 的表。

  ```sql
  CREATE TABLE tbl6 (c1 VARCHAR(10),
                   c2 VARCHAR(10) CHARSET GBK COLLATE gbk_bin)
               DEFAULT CHARSET utf8 COLLATE utf8mb4_general_ci;
  Query OK, 0 rows affected (0.029 sec)
  ```

* 开启 Encoding 并使用 `zstd` 压缩，宏块保留空间为 `5%`。

  ```sql
  CREATE TABLE tbl7 (c1 INT, c2 INT, c3 VARCHAR(64))
        COMPRESSION 'zstd_1.0'
        ROW_FORMAT DYNAMIC
        PCTFREE 5;
  Query OK, 0 rows affected (0.032 sec)
  ```

* 创建表 `tbl8`，并设置并行度为 `3`。

  ```sql
  CREATE TABLE tbl8(c1 INT PRIMARY KEY, c2 INT) PARALLEL 3;
  Query OK, 0 rows affected (0.051 sec)
  ```

* 使用自增列作为分区键。

  ```sql
  CREATE TABLE tbl9(inv_id BIGINT NOT NULL AUTO_INCREMENT,c1 BIGINT,
  PRIMARY KEY (inv_id) ) PARTITION BY HASH(inv_id) PARTITIONS 8;
  Query OK, 0 rows affected (0.035 sec)
  ```

* 为表 `ref_t2` 指定外键，当 `UPDATE` 操作影响与子表相匹配行的父表中键值时，执行 `SET NULL` 操作。

  ```shell
  CREATE TABLE ref_t1(c1 INT PRIMARY KEY, C2 INT);
  Query OK, 0 rows affected (0.094 sec)

  CREATE TABLE ref_t2(c1 INT PRIMARY KEY, C2 INT,FOREIGN KEY(c2) REFERENCES ref_t1(c1) ON UPDATE SET NULL);
  Query OK, 0 rows affected (0.074 sec)
  ```

* 创建带 `CHECK` 约束的表 `tbl10`，并查看约束信息。

  ```sql
  CREATE TABLE tbl10 (col1 INT, col2 INT, col3 INT, CONSTRAINT equal_check1 CHECK(col1 = col3 * 2));
  Query OK, 0 rows affected

  SHOW CREATE TABLE tbl10;
  +-------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
  | Table | Create Table                                                                                                                                                                                                                                                                                                                                               |
  +-------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
  | tbl10  | CREATE TABLE `tbl10` (
    `col1` int(11) DEFAULT NULL,
    `col2` int(11) DEFAULT NULL,
    `col3` int(11) DEFAULT NULL,
    CONSTRAINT `equal_check1` CHECK ((`col1` = (`col3` * 2)))
  ) DEFAULT CHARSET = utf8mb4 ROW_FORMAT = DYNAMIC COMPRESSION = 'zstd_1.3.8' REPLICA_NUM = 1 BLOCK_SIZE = 16384 USE_BLOOM_FILTER = FALSE TABLET_SIZE = 134217728 PCTFREE = 0 |
  +-------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
  1 row in set (0.001 sec)
  ```

* 依照表 `tbl10` 创建表 `tbl11`，并查看表信息。

  ```sql
  CREATE TABLE tbl11 LIKE tbl10;
  Query OK, 0 rows affected

  SHOW CREATE TABLE tbl11;
  +-------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
  | Table | Create Table                                                                                                                                                                                                                                                                                                                                                                |
  +-------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
  | tbl11  | CREATE TABLE `tbl11` (
    `col1` int(11) DEFAULT NULL,
    `col2` int(11) DEFAULT NULL,
    `col3` int(11) DEFAULT NULL,
    CONSTRAINT `tbl11_OBCHECK_1650793233327894` CHECK ((`col1` = (`col3` * 2)))
  ) DEFAULT CHARSET = utf8mb4 ROW_FORMAT = DYNAMIC COMPRESSION = 'zstd_1.3.8' REPLICA_NUM = 1 BLOCK_SIZE = 16384 USE_BLOOM_FILTER = FALSE TABLET_SIZE = 134217728 PCTFREE = 0 |
  +-------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
  1 row in set (0.001 sec)
  ```

* 创建列存表 `tbl1_cg`。

  ```sql
  CREATE TABLE tbl1_cg (col1 INT PRIMARY KEY, col2 VARCHAR(50)) WITH COLUMN GROUP(each column);
  ```

* 创建带列存索引的表。

  ```sql
  CREATE TABLE tbl2_cg (col1 INT PRIMARY KEY, col2 INT, col3 INT, INDEX i1 (col2) WITH COLUMN GROUP(each column));
  ```

* 创建带列存索引的列存表。

  ```sql
  CREATE TABLE tbl3_cg (col1 INT PRIMARY KEY, col2 INT, col3 INT, INDEX i1 (col2) WITH COLUMN GROUP(each column)) WITH COLUMN GROUP(each column);
  ```

* 创建表时标识列 Skip Index 属性。

  ```sql
  CREATE TABLE test_skidx(
    col1 INT SKIP_INDEX(MIN_MAX, SUM),
    col2 FLOAT SKIP_INDEX(MIN_MAX),
    col3 VARCHAR(1024) SKIP_INDEX(MIN_MAX),
    col4 CHAR(10)
  );
  ```

* 创建表 `tbl1`，它有一个整数类型的列 `col1`，并且指定该操作应用 5 个并行度来完成，指定了新表 `tbl1` 的数据内容将来源于表 `tbl2` 的查询结果。

  ```sql
  CREATE /*+ parallel(5) */ TABLE tbl1 (col1 INT) AS SELECT col1 FROM tbl2;
  ```

* 创建开启持久化宏块级别 bloom filter 的表 `tb`。

  ```sql
  CREATE TABLE tb(c1 INT PRIMARY KEY, c2 INT) enable_macro_block_bloom_filter = True;
  ```

## 相关文档

* [创建表](https://www.oceanbase.com/docs/common-oceanbase-database-cn-1000000002015448)
* [更改表](https://www.oceanbase.com/docs/common-oceanbase-database-cn-1000000002015441)