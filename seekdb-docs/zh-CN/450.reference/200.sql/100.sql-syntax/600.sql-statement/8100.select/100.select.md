---
slug: /select
---

# SELECT

## 描述

该语句用于从一个或多个表中查询数据。

本节主要介绍通用的 `SELECT` 语法结构。其他 `SELECT` 相关的语法，参见：

* [JOIN 子句](200.join-clause.md)
* [WINDOW 子句](300.over-clause.md)
* [UNION 子句](400.union-clause.md)
* [SELECT INTO](../8000.select-into.md)

## 权限要求

执行 `SELECT` 语句，需要当前用户拥有 `SELECT` 权限。有关 seekdb 权限的详细介绍，参见 [seekdb 的权限分类](../../../../../400.guides/500.manage/300.security/300.access-control/200.user-and-permission/100.permission-classification.md)。

## 语法

```sql
select_stmt:
    SELECT [hint_options]
        [{DISTINCT | UNIQUE} | ALL]
        [SQL_CALC_FOUND_ROWS]
        [STRAIGHT_JOIN]
        select_expr_list
        [FROM from_list]
        [WHERE where_condition]
        [GROUP BY group_by_condition_list [WITH ROLLUP]
         | GROUP BY [group_by_condition_list] group_by_summary_option (expression_list)]
        [HAVING having_condition]
        [window_clause]
        [ORDER BY order_by_condition_list]
        [LIMIT limit_clause]
        [lock_option];

select_expr_list:
    select_expr [, select_expr ...]

select_expr:
    *
    | table_name.{* | column_name}
    | table_alias_name.{* | column_name}
    | expr [[AS] column_alias_name]

from_list:
    DUAL
    | table_references
    | { location_url | table_function }

location_url:
  '<string>'
  (
  {FORMAT = (
      TYPE = 'CSV',
      LINE_DELIMITER = '<string>' | <expr>,
      FIELD_DELIMITER = '<string>' | <expr>,
      ESCAPE = '<character>' | <expr>,
      FIELD_OPTIONALLY_ENCLOSED_BY = '<character>' | <expr>,
      ENCODING = 'charset',
      NULL_IF = ('<string>' | <expr>, '<string>' | <expr> ...),
      SKIP_HEADER = <int>,
      SKIP_BLANK_LINES = { TRUE | FALSE },
      PARSE_HEADER = { TRUE | FALSE },
      TRIM_SPACE = { TRUE | FALSE },
      EMPTY_FIELD_AS_NULL = { TRUE | FALSE }
    )
   | FORMAT = ( TYPE = 'PARQUET' | 'ORC' )
  }
  [PATTERN = '<regex_pattern>']
  )

table_function:
  {
  FILES (
    LOCATION = '<string>',
    {
      FORMAT = (
        TYPE = 'CSV',
        LINE_DELIMITER = '<string>' | <expr>,
        FIELD_DELIMITER = '<string>' | <expr>,
        ESCAPE = '<character>' | <expr>,
        FIELD_OPTIONALLY_ENCLOSED_BY = '<character>' | <expr>,
        ENCODING = 'charset',
        NULL_IF = ('<string>' | <expr>, '<string>' | <expr> ...),
        SKIP_HEADER = <int>,
        SKIP_BLANK_LINES = { TRUE | FALSE },
        PARSE_HEADER = { TRUE | FALSE },
        TRIM_SPACE = { TRUE | FALSE },
        EMPTY_FIELD_AS_NULL = { TRUE | FALSE }
      )
      | FORMAT = ( TYPE = 'PARQUET' | 'ORC' )
    },
    [PATTERN = '<regex_pattern>']
  )
  | SOURCE (
      TYPE = 'ODPS',
      ACCESSID = '<string>',
      ACCESSKEY = '<string>',
      ENDPOINT = '<string>',
      TUNNEL_ENDPOINT = '<string>',
      PROJECT_NAME = '<string>',
      SCHEMA_NAME = '<string>',
      TABLE_NAME = '<string>',
      QUOTA_NAME = '<string>',
      COMPRESSION_CODE = '<string>'
    )
  }

where_condition:
    expression

group_by_condition_list:
    group_by_condition [, group_by_condition ...]

group_by_condition:
    expression [ASC | DESC]

group_by_summary_option:
    GROUPING SETS
    | ROLLUP
    | CUBE

expression_list:
    expression [, expression ...]

having_condition:
    expression

order_by_condition_list:
    order_by_condition [, order_by_condition ...]

order_by_condition:
    expression [ASC | DESC]

limit_clause:
    [offset,] row_count
    | row_count OFFSET offset

lock_option:
    FOR UPDATE [opt_for_update_wait]
    | LOCK IN SHARE MODE

opt_for_update_wait:
    WAIT {decimal | intnum}
    | NOWAIT
    | NO_WAIT
    | SKIP LOCKED
```

## 参数解释

|              参数             |                           描述                       |
|-------------------------------|------------------------------------------------------|
| select_stmt                   | 用来指定要从数据库中检索哪些数据的 SQL 语句部分。|
| hint_options                  | 可选项，用于指定 `hint` 选项。有关 Hint 的介绍信息，参见 [Optimizer Hint](https://www.oceanbase.com/docs/common-oceanbase-database-cn-1000000002016228)。|
| \{DISTINCT \| UNIQUE\} \| ALL   | 可选项，用于控制返回的结果集中是否包含重复的行。<ul><li>`DISTINCT`/`UNIQUE`：表示返回的结果集中不包含重复行。</li><li>`ALL`：表示查询结果中包含所有的行，包括重复的行。缺省为 `ALL`。</li></ul>|
| SQL_CACHE \| SQL_NO_CACHE     | 可选项，用于控制查询结果是否被缓存。<ul><li>`SQL_CACHE`：表示查询结果会被缓存。</li><li>`SQL_NO_CACHE`：表示查询结果不会被缓存。</li></ul>|
| SQL_CALC_FOUND_ROWS           | 可选项，用于在带有 `LIMIT` 子句的查询中，记录全部返回的行数，并可以在接下来执行的 `FOUND_ROWS()` 函数获取全部行数。|
| STRAIGHT_JOIN                 | 可选项，强制优化器按照 `FROM` 子句中所列出的顺序连接表。调优命令，不影响执行结果。:::tip seekdb 并不完全兼容 MySQL 中的 `STRAIGHT_JOIN` 语法。当 `STRAIGHT_JOIN` 能够明确指定表连接的顺序时，seekdb 会按照这个命令执行。如果 `STRAIGHT_JOIN` 无法确定唯一的连接顺序，seekdb 将会忽略这个命令。 ::: |
| select_expr_list              | 指定要在查询结果中显示的列或表达式列表。查询出列或表达式的详细介绍可参见下文 [select_expr](#select_expr)。|
| column_name                   | 列名称。|
| FROM from_list                | 可选项，指定查询的数据源，可以是表、视图或者子查询。数据源的详细介绍可参见下文 [from_list](#from_list)。|
| \{ table_function \| location_url \} |可选项，当前 URL 外表支持两种语法形式，详细介绍可参见下文：<ul><li> [table_function](#table_function) 形式。</li><li>[location_url](#location_url) 形式。</li></ul>|
| WHERE where_condition         | 可选项，指定查询的筛选条件。详细介绍可参见下文 [where_condition](#where_condition)。|
| GROUP BY group_by_condition_list | 可选项，用于按照指定的列对结果进行分组。通常与聚合函数一起使用。详细介绍可参见下文 [group_by_condition](#group_by_condition)。|
| WITH ROLLUP                   | 可选项，将各分组进行汇总以表示更高级的聚合（也称为超聚合），并产生额外的行。|
| GROUP BY [group_by_condition_list] group_by_summary_option (expression_list) | 可选项，用于高级分组汇总操作。<ul><li> `group_by_condition_list`：可选项，用于指定按哪些列或表达式进行分组。详细介绍可参见下文 [group_by_condition](#group_by_condition)。 <ul><li>当明确指定 `group_by_condition_list` 时，这些列会被视为固定的分组条件。它们会与后续的 `group_by_summary_option` 结合使用，形成最终的分组逻辑。例如，`GROUP BY col1, GROUPING SETS ((col2), (col3))` 等价于 `GROUP BY GROUPING SETS ((col1, col2), (col1, col3))`。</li><li>如果未指定 `group_by_condition_list`，则所有的分组逻辑完全由 `group_by_summary_option` 决定。即分组条件完全依赖于 `expression_list` 中的列或表达式。</li></ul> </li><li> `group_by_summary_option`：表示高级汇总选项，详细介绍可参见下文 [group_by_summary_option](#group_by_summary_option)。</li><li>`expression_list`：表示一个或多个列名、别名或表达式的列表。用于指定汇总的维度。</li></ul> :::info seekdb 支持高级分组汇总操作。 ::: |
| HAVING having_condition       | 可选项，用于对分组后的结果进行条件过滤。`HAVING` 字句与 `WHERE` 字句类似，但是 `HAVING` 字句可以使用聚合函数（如 `SUM`，`AVG` 等）。详细介绍可参见下文 [having_condition](#having_condition)。|
| window_clause                 | 可选项，用于指定分析函数（某些数据库下也叫做窗口函数）的窗口定义。`window_clause` 的详细语法信息，参见 [WINDOW 子句](300.over-clause.md)。|
| ORDER BY order_by_condition_list | 可选项，用于对结果集进行排序。可以指定一个或多个列进行排序。详细介绍可参见下文 [order_by_condition](#order_by_condition)。|
| LIMIT limit_clause            | 可选项，用于指定限制返回结果的数量（行数）。详细介绍可参见下文 [limit_clause](#limit_clause)。|
| lock_option                   | 可选项，用于对查询结果加锁。详细介绍可参见下文 [lock_option](#lock_option)。|

### select_expr

`select_expr`：表示查询结果中包含的列或表达式，多个表达式或列名间以英文逗号（`,`）分隔。取值如下：

* `*`：表示选择所有列。

  **示例如下：**

  1. 创建表 `tbl1` 和 `tbl2`。

     ```sql
     CREATE TABLE tbl1(col1 INT PRIMARY KEY, col2 VARCHAR(20), col3 INT)
       PARTITION BY HASH(col1)
       PARTITIONS 5;
     ```

     ```sql
     CREATE TABLE tbl2(col1 INT PRIMARY KEY, col2 VARCHAR(20), col3 INT);
     ```

  2. 向表 `tbl1` 中插入测试数据。

     ```sql
     INSERT INTO tbl1 VALUES(1, 'A1', 1),(2, 'A2', 2),(3, 'A3', 3);
     ```

     ```sql
     INSERT INTO tbl2 VALUES(1, 'A1', 1),(2, 'A2', 22),(3, 'A3', 33);
     ```

  3. 查看表 `tbl1` 中的数据。

     ```sql
     SELECT * FROM tbl1;
     ```

     返回结果如下：

     ```shell
     +------+------+------+
     | col1 | col2 | col3 |
     +------+------+------+
     |    1 | A1   |    1 |
     |    2 | A2   |    2 |
     |    3 | A3   |    3 |
     +------+------+------+
     3 rows in set (0.022 sec)
     ```

* `table_name.{* | column_name}`：表示选择指定表中的所有列或者指定列。

  * `table_name.*`：表示选择指定表中的所有列。

  * `table_name.column_name`：表示选择指定表中的某一列。

    **示例如下：**

    从表 `tbl1` 中读取 `col1` 数据。

    ```sql
    SELECT tbl1.col1 FROM tbl1;
    ```

    返回结果如下：

    ```shell
    +------+
    | col1 |
    +------+
    |    1 |
    |    2 |
    |    3 |
    +------+
    3 rows in set (0.025 sec)
    ```

* `table_alias_name.{* | column_name}`: 和上面的格式类似，只是在选择列的时候使用了表的别名。

* `expr [[AS] column_alias_name]`：表示选择一个表达式，并可以给这个选中的表达式起一个别名作为列的名称。

  * `expr`：表示一个列名、函数、计算表达式等。

    * `expr AS column_alias_name`/`expr column_alias_name`：表示选择这个表达式，并将其命名为`column_alias_name`。

  **示例如下：**

  从表 `tbl1` 中读取 `col1` 的数据，并计算得出新列 `col1_add`，其值为 `col1+1`。另外还通过计算 `col3*2` 得出新列 `col3_mul`。

  ```sql
  SELECT col1, col1+1 AS col1_add, col3*2 col3_mul FROM tbl1;
  ```

  返回结果如下：

  ```shell
  +------+----------+----------+
  | col1 | col1_add | col3_mul |
  +------+----------+----------+
  |    1 |        2 |        2 |
  |    2 |        3 |        4 |
  |    3 |        4 |        6 |
  +------+----------+----------+
  3 rows in set (0.027 sec)
  ```

### from_list

* `DUAL`：表示虚拟表名。通常用于在没有实际表的情况下执行一些计算或函数。

  **示例如下：**

  ```sql
  SELECT 1+1, SYSDATE() FROM DUAL;
  ```

  返回结果如下：

  ```shell
  +------+---------------------+
  | 1+1  | SYSDATE()           |
  +------+---------------------+
  |    2 | 2024-08-28 15:20:59 |
  +------+---------------------+
  1 row in set (0.009 sec)
  ```

* `table_references`：表引用列表，可以包括多个表引用，多个表引用间使用英文逗号（`,`）分隔。即指定查询的数据源表列表，可以是一个或多个表的组合。`table_references` 的详细语法信息，参见 [JOIN 子句](200.join-clause.md)。

### where_condition

`expression`：表示可用于过滤要更新的行的条件表达式。

**示例如下：**

从 `tbl1` 表中选取满足条件 `col1 > 1` 并且 `col2 = 'A3'` 的所有行数据。

```sql
SELECT * FROM tbl1
  WHERE col1 > 1
  AND col2 = 'A3';
```

返回结果如下：

```shell
+------+------+------+
| col1 | col2 | col3 |
+------+------+------+
|    3 | A3   |    3 |
+------+------+------+
1 row in set (0.003 sec)
```

### table_function

* LOCATION 子句用于指定外表文件存放的路径。通常外表的数据文件存放于单独一个目录中，文件夹中可以包含子目录，在创建表时，外表会自动收集该目录中的所有文件。

  * 本地 `LOCATION` 格式为 `LOCATION = '[file://] local_file_path'`，其中 `local_file_path` 可以为相对路径，也可以为绝对路径。如果填写的是相对路径，则当前目录必须为 seekdb 的安装目录；`secure_file_priv` 用于配置 seekdb 节点有权限访问的文件路径。`local_file_path` 只能是 `secure_file_priv` 路径的子路径。
  * 远程 `LOCATION` 格式为：
    * `LOCATION = '{oss\|s3}://$ACCESS_ID:$ACCESS_KEY@$HOST：s3_region/remote_file_path'`，其中 `$ACCESS_ID`、`$ACCESS_KEY` 和 `$HOST` 为访问阿里云 OSS、AWS S3 以及兼容 S3 协议的对象存储所需配置的访问信息，`s3_region` 为使用 S3 时选择的区域信息，这些敏感的访问信息会以加密的方式存放在数据库的系统表中。
    * `LOCATION = hdfs://localhost:port/PATH`，其中 `localhost` 指的是 HDFS 的地址，`port` 指的是 HDFS 的端口号，`PATH` 指 HDFS 中的目录路径。
      * 带 kerberos 认证：`LOCATION = 'hdfs://localhost:port/user?principal=xxx&keytab=xxx&krb5conf=xxx&configs=xxx'`。
      其中：
        * `principal`: 指登录认证用户。
        * `keytab`:指定用户认证的密钥文件路径。
        * `krb5conf`:指定用户使用 kerberos 环境的描述文件路径。
        * `configs`: 指定额外的 HDFS 配置项，默认为空，但是如果是 kerberos 环境，则通常该配置项有值，需要进行配置，例如：`dfs.data.transfer.protection=authentication,privacy`，指定数据传输保护级别为 `authentication` 和 `privacy`。

* FORMAT 子句用于指定读取文件格式相关的属性，支持 CSV/PARQUET/ORC 三种文件格式。

  * **TYPE = 'CSV'** 时，包含以下字段：
    * `LINE_DELIMITER`：指定 CSV 文件的行分隔符，默认为 `LINE_DELIMITER='\n'`。
    * `FIELD_DELIMITER`：可选项，指定 CSV 文件的列分隔符，默认为 `FIELD_DELIMITER='\t'`。
    * `ESCAPE`：指定 CSV 文件的转义符号，只能为 1 个字节，默认为 `ESCAPE ='\'`。
    * `FIELD_OPTIONALLY_ENCLOSED_BY`：可选项，指定 CSV 文件中包裹字段值的符号，默认为空。使用此选项表示只对部分类型的字段（如 CHAR, VARCHAR, TEXT, JSON 等）加包裹符。
    * `ENCODING`：指定文件的字符集编码格式，如果不指定，默认值为 `UTF8MB4`。
    * `NULL_IF`：指定被当作 `NULL` 处理的字符串。默认值为空。
    * `SKIP_HEADER`：跳过文件头，并指定跳过的行数。
    * `SKIP_BLANK_LINES`：指定是否跳过空白行。默认值为 `FALSE`，表示不跳过空白的行。
    * `TRIM_SPACE`：指定是否删除文件中字段的头部和尾部空格。默认值为 `FALSE`，表示不删除文件中字段头尾的空格。
    * `EMPTY_FIELD_AS_NULL`：指定是否将空字符串当作 `NULL` 处理。默认值为 `FALSE`，表示不将空字符串当做 `NULL` 处理。
    * `PARSE_HEADER`:指定该配置后直接获取 CSV 文件第一行信息，将其作为每列的列名。<main id="notice" type='notice'><h4>注意</h4><p>`PARSE_HEADER`不能和 `SKIP_HEADER` 同时使用，语意上会有冲突。</p></main>
  * **TYPE = 'PARQUET/ORC'** 时，无其他额外字段。

* `PATTERN` 子句指定一个正则模式串，用于过滤 `LOCATION` 目录下的文件。对于每个 LOCATION 目录下的文件路径，如果能够匹配该模式串，外表会访问这个文件，否则外表会跳过这个文件。如果不指定该参数，则默认可以访问 `LOCATION` 目录下的所有文件。

对于 ODPS 格式，因为获取数据的方式不是通过文件，并且不存在有意义的 URL 路径，所以只支持 `source` 这一种 table_function 的形式。

* **TYPE = 'ODPS'** 包含以下字段：
  * `ACCESSID`：指定 ODPS 用户的 ID。
  * `ACCESSKEY`：指定 ODPS 用户的密码。
  * `ENDPOINT`：指定 ODPS 服务的连接地址。
  * `TUNNEL_ENDPOINT`：指定 Tunnel 数据传输服务的连接地址。
  * `PROJECT_NAME`：指定需要查询的表所在的 Project。
  * `SCHEMA_NAME`：可选项，指定需要查询表的 SCHEMA。
  * `TABLE_NAME`：指定需要查询的表名。
  * `QUOTA_NAME`：可选项，选择是否使用指定的 Quota。
  * `COMPRESSION_CODE`：可选项，指定数据源的压缩格式，支持 ZLIB、ZSTD、LZ4、ODPS_LZ4 四种压缩格式，不设置表示不开启压缩。

**示例如下：**

读取 odps 格式数据。

```sql
SELECT * FROM
source (
  type = 'ODPS',
  accessid = '$ODPS_ACCESSID',
  accesskey = '$ODPS_ACCESSKEY',
  endpoint= '$ODPS_ENDPOINT',
  project_name = 'example_project',
  schema_name = '',
  table_name = 'example_table',
  quota_name = '',
  compression_code = ''
);
```

### location_url

* FORMAT 子句用于指定读取件格式相关的属性，支持 CSV/PARQUET/ORC 三种文件格式：
  * CSV 格式：配置 parse_header=true/false：指定是否解析文件首行为列标题（默认为 false）。另外，需要使用 TYPE=CSV 声明文件格式（导出时需指定）。
  * PARQUET/ORC 格式：自动识别文件结构，无需额外配置标题行。

**示例如下：**

```sql
SELECT * FROM
FILES( location = '/data/',
      format (TYPE = 'csv', field_delimiter = ',', parse_header = true),
      pattern = 'datafiles$';
```

### group_by_condition

`expression [ASC | DESC]`：表示分组的条件表达式。加入升序（`ASC`）或者降序（`DESC`）可以控制分组后的结果集中，各个分组的顺序是升序还是降序。

**示例如下：**

从表 `tbl1` 中查询 `col1`、`col2`，按照 `col2` 分组对 `col3` 求和，并输出。

```sql
SELECT col1, col2, SUM(col3)
  FROM tbl1
  GROUP BY col2 DESC;
```

返回结果如下：

```shell
+------+------+-----------+
| col1 | col2 | SUM(col3) |
+------+------+-----------+
|    3 | A3   |         3 |
|    2 | A2   |         2 |
|    1 | A1   |         1 |
+------+------+-----------+
3 rows in set (0.017 sec)
```

### group_by_summary_option

:::info
seekdb 支持高级分组汇总操作。
:::

* `GROUPING SETS`：表示自定义分组方式，允许指定多个分组组合。具有以下特点：

  * 用户可以灵活定义需要的分组组合。
  * 生成的结果集仅包括用户指定的分组组合。

  :::info
  `GROUP BY GROUPING SETS ((col1), (col2), (col3))` 等价于 `GROUP BY GROUPING SETS (col1, col2, col3)`。
  :::

  **示例如下：**

  ```sql
  SELECT col1, col2, col3, COUNT(*)
  FROM tbl1
  GROUP BY GROUPING SETS ((col1), (col2), (col3));
  ```

  返回结果如下：

  ```shell
  +------+------+------+----------+
  | col1 | col2 | col3 | COUNT(*) |
  +------+------+------+----------+
  |    1 | NULL | NULL |        1 |
  |    2 | NULL | NULL |        1 |
  |    3 | NULL | NULL |        1 |
  | NULL | A1   | NULL |        1 |
  | NULL | A2   | NULL |        1 |
  | NULL | A3   | NULL |        1 |
  | NULL | NULL |    1 |        1 |
  | NULL | NULL |    2 |        1 |
  | NULL | NULL |    3 |        1 |
  +------+------+------+----------+
  9 rows in set (0.016 sec)
  ```

* `ROLLUP`：表示分层汇总方式，按照分组列的顺序逐层减少分组列的数量，生成多层次的汇总结果。具有以下特点：

  * 按照 `expression_list` 中的列顺序，依次减少分组列，直到只保留总计行。

  * 生成的结果集包括：

    * 每个分组的明细数据。
    * 每个分组的子汇总数据。
    * 总计行。

  `ROLLUP` 可以看作特殊的 `GROUPING SETS`。例如：

  ```sql
  GROUP BY ROLLUP(col1, col2, col3)

  等价于

  GROUP BY GROUPING SETS ((col1, col2, col3), (col1, col2), (col1), ())
  ```

  `ROLLUP` 也可以与 `GROUPING SETS` 组合使用。例如：

  ```sql
  GROUP BY GROUPING SETS((col2), (col3), ROLLUP(col1, col2, col3))

  等价于

  GROUP BY GROUPING SETS((col2), (col3), (col1, col2, col3), (col1, col2), (col1), ())
  ```

  **示例如下：**

  ```sql
  SELECT col1, col2, col3, COUNT(*)
  FROM tbl1
  GROUP BY ROLLUP (col1, col2, col3);
  ```

  返回结果如下：

  ```shell
  +------+------+------+----------+
  | col1 | col2 | col3 | COUNT(*) |
  +------+------+------+----------+
  |    1 | A1   |    1 |        1 |
  |    1 | A1   | NULL |        1 |
  |    1 | NULL | NULL |        1 |
  |    2 | A2   |    2 |        1 |
  |    2 | A2   | NULL |        1 |
  |    2 | NULL | NULL |        1 |
  |    3 | A3   |    3 |        1 |
  |    3 | A3   | NULL |        1 |
  |    3 | NULL | NULL |        1 |
  | NULL | NULL | NULL |        3 |
  +------+------+------+----------+
  10 rows in set (0.109 sec)
  ```

* `CUBE`：表示多维汇总方式，用于生成所有可能的分组组合。具有以下特点：

  * 每个分组的明细数据。
  * 所有可能的分组组合的汇总数据。
  * 总计行。

  `CUBE` 可以看作特殊的 `GROUPING SETS`。例如：

  ```sql
  GROUP BY CUBE(col1, col2, col3)

  等价于

  GROUP BY GROUPING SETS ((col1, col2, col3), (col1, col2), (col1, col3), (col2, col3), (col1), (col2), (col3), ())
  ```

  `CUBE` 也可以与 `GROUPING SETS` 组合使用。例如：

  ```sql
  GROUP BY col1, CUBE(col2, col3), GROUPING SETS((col4), (col5))

  等价于

  GROUP BY GROUPING SETS(
    (col1, col2, col3, col4), (col1, col2, col3, col5),
    (col1, col2, col4), (col1, col2, col5),
    (col1, col3, col4), (col1, col3, col5),
    (col1, col4), (col1, col5))
  ```

  **示例如下：**

  ```sql
  SELECT col1, col2, col3, COUNT(*)
  FROM tbl1
  GROUP BY CUBE (col1, col2, col3);
  ```

  返回结果如下：

  ```shell
  +------+------+------+----------+
  | col1 | col2 | col3 | COUNT(*) |
  +------+------+------+----------+
  | NULL | NULL | NULL |        3 |
  | NULL | NULL |    1 |        1 |
  | NULL | NULL |    2 |        1 |
  | NULL | NULL |    3 |        1 |
  | NULL | A1   | NULL |        1 |
  | NULL | A2   | NULL |        1 |
  | NULL | A3   | NULL |        1 |
  | NULL | A1   |    1 |        1 |
  | NULL | A2   |    2 |        1 |
  | NULL | A3   |    3 |        1 |
  |    1 | NULL | NULL |        1 |
  |    2 | NULL | NULL |        1 |
  |    3 | NULL | NULL |        1 |
  |    1 | NULL |    1 |        1 |
  |    2 | NULL |    2 |        1 |
  |    3 | NULL |    3 |        1 |
  |    1 | A1   | NULL |        1 |
  |    2 | A2   | NULL |        1 |
  |    3 | A3   | NULL |        1 |
  |    1 | A1   |    1 |        1 |
  |    2 | A2   |    2 |        1 |
  |    3 | A3   |    3 |        1 |
  +------+------+------+----------+
  22 rows in set (0.113 sec)
  ```

### having_condition

`expression`：表示对分组后的结果进行条件过滤的条件表达式。

**示例如下：**

从表 `tbl1` 中查询 `col1`、`col2`，按照 `col2` 分组对 `col3` 求和，查询 `col3` 总和小于 `3` 的行，并输出。

```sql
SELECT col1, col2, SUM(col3)
  FROM tbl1
  GROUP BY col2
  HAVING SUM(col3) < 3;
```

返回结果如下：

```shell
+------+------+-----------+
| col1 | col2 | SUM(col3) |
+------+------+-----------+
|    1 | A1   |         1 |
|    2 | A2   |         2 |
+------+------+-----------+
2 rows in set (0.010 sec)
```

### order_by_condition

`expression [ASC | DESC]`：表示对结果集排序的条件表达式。

`ASC | DESC`：可选参数，用于指定排序的顺序。`ASC` 表示升序（默认），`DESC` 表示降序。

**示例如下：**

查询表 `tbl1` 的数据，根据 `col3` 按降序（`DESC`）输出查询结果。

```sql
SELECT * FROM tbl1
  ORDER BY col3 DESC;
```

返回结果如下：

```shell
+------+------+------+
| col1 | col2 | col3 |
+------+------+------+
|    3 | A3   |    3 |
|    2 | A2   |    2 |
|    1 | A1   |    1 |
+------+------+------+
3 rows in set (0.012 sec)
```

### limit_clause

* `[offset,] row_count`：参数取值必须是整数常量，解释如下：

  * `offset`：可选项，表示从结果集的起始位置开始跳过的行数（偏移量）。默认初始记录行的偏移量是 0。
  * `row_count`：表示要返回的行数。如果只使用 `row_count` 参数，则返回结果集的前 `row_count` 行。

* `row_count OFFSET offset`：表示从结果集的起始位置跳过 `offset` 行，然后返回接下来的 `row_count` 行。

**示例如下：**

查询表 `tbl1` 的数据，使用 `LIMIT` 强制从第 2 行开始，返回表 `tbl1` 的两行结果。

```sql
SELECT * FROM tbl1
  LIMIT 1, 2;
```

返回结果如下：

```shell
+------+------+------+
| col1 | col2 | col3 |
+------+------+------+
|    2 | A2   |    2 |
|    3 | A3   |    3 |
+------+------+------+
2 rows in set (0.011 sec)
```

### lock_option

* `FOR UPDATE [opt_for_update_wait]`：表示对查询结果所有行加上排他锁，以阻止其他事务的并发修改，或阻止在某些事务隔离级别时的并发读取。有关使用排他锁的介绍信息，参见 [锁定查询结果 SELECT FOR UPDATE](../../../../../200.develop/300.read-and-write-data/200.read-data/300.use-operators-and-functions-in-query/1000.lock-query-results-select-for-update.md)。

  * `opt_for_update_wait`：可选项，用于指定获取锁的行为。具体如下：

    * `WAIT {decimal | intnum}`：表示等待其他事务释放资源的时间，如果超过该时间，则返回无法获得资源，单位为秒。
    * `NOWAIT`/`NO_WAIT`：表示不等待其他事务释放资源，直接返回无法获得资源。
    * `SKIP LOCKED`：表示不会等待获取行锁，查询会立即执行，从结果集中移除被锁定的行。

  **示例如下：**

  * 可以通过 `SELECT ... FOR UPDATE` 为表加行级锁。如果使用了 `LIMIT 1` 子句，则会在查询优化中将算子下压到表扫描的步骤中，只为 `LIMIT` 返回的行加锁。

    ```sql
    SELECT * FROM tbl1
      LIMIT 1
      FOR UPDATE;
    ```

  * 如果您使用了 `ORDER BY` 子句对查询结果进行排序，则会先对结果进行排序，然后再执行 `LIMIT 1`，因此这种情况下，会为选择的所有行加锁。

    ```sql
    SELECT * FROM tbl1
      ORDER BY col1
      LIMIT 1
      FOR UPDATE;
    ```

* `LOCK IN SHARE MODE`：用于在查询数据时获取共享锁，防止其他事务对数据进行写操作，但允许其他事务对数据进行读操作。有关使用共享锁的介绍信息，参见 [锁定查询结果 LOCK IN SHARE MODE](../../../../../200.develop/300.read-and-write-data/200.read-data/300.use-operators-and-functions-in-query/1100.query-results-lock-in-share.md)。

## 示例

### 简单的表查询示例

1. 创建表 `test_tbl1`。

   ```sql
   CREATE TABLE test_tbl1(col1 INT PRIMARY KEY, col2 VARCHAR(20), col3 INT);
   ```

2. 向表 `test_tbl1` 中插入测试数据。

   ```sql
   INSERT INTO test_tbl1 VALUES (1, 'A1', 10),(2, 'A2', 15),(3, 'A1', 8);
   ```

3. 查看表 `test_tbl1` 中列 `col2` 的数据并进行去重处理。

   ```sql
   SELECT DISTINCT col2 FROM test_tbl1;
   ```

   返回结果如下：

   ```shell
   +------+
   | col2 |
   +------+
   | A1   |
   | A2   |
   +------+
   2 rows in set (0.014 sec)
   ```

### 使用 dblink 查询数据的示例

* 读取远端 `test` 库中的 `number_t` 表

  ```sql
  SELECT * FROM number_t@ob_dblink;
  ```

  返回结果如下：

  ```shell
  +--------+-------------+---------+---------------------+--------------------------------+
  | c_int  | c_bigint    | c_float |    c_double         |   c_decimal                    |
  +--------+-------------+---------+---------------------+--------------------------------+
  | 214748 | 92233720368 | 3.40282 | 1.7976931348623157  | 123456789123456789.1234567890  |
  +--------+-------------+---------+---------------------+--------------------------------+
  1 row in set (0.013 sec)
  ```

* 读取远端 `test` 库中的 `number_t` 表，并和本地的 `number_t` 表做 JOIN 操作。

  ```sql
  SELECT a.c_decimal, b.c_double
    FROM number_t a, number_t@ob_dblink b
    WHERE a.c_int = b.c_int;
  ```

  返回结果如下：

  ```shell
  +--------------------------------+---------------------+
  |   c_decimal                    |    c_double         |
  +---------------------+--------------------------------+
  | 123456789123456789.1234567890  |  1.7976931348623157 |
  +---------------------+--------------------------------+
  1 row in set (0.017 sec)
  ```

* 读取远端 `mysql` 库中的 `datetime_t` 表。

  ```sql
  SELECT * FROM mysql.datetime_t@ob_dblink;
  ```

  返回结果如下：

  ```shell
  +-------------+------------+---------+----------------------+----------------------+
  | c_date      | c_time     | c_year  | c_datetime           |  c_timestamp         |
  +-------------+------------+---------+-----------------------+---------------------+
  |  2023-04-13 | 12:12:12   |  2078   | 2100-11-01 12:12:13  | 2100-12-01 21:14:15  |
  +-------------+------------+---------+----------------------+----------------------+
  1 row in set (0.015 sec)
  ```

## 相关文档

[单表查询](../../../../../200.develop/300.read-and-write-data/200.read-data/100.single-table-query.md)