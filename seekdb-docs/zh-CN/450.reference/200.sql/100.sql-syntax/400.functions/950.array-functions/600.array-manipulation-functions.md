---

slug: /array-manipulation-functions

---

# 数组操作函数

数组操作函数对输入的数组数据进行一些基本操作，如添加元素、删除元素、查找元素，并返回操作后的数组数据。seekdb 当前所支持的数组操作函数包括 `array_append()`、`arrar_distinct()`、`array_remove()`、`cardinality()`、`element_at()`、`string_to_array()`、`array_agg()`、`unnest()`、`split()` 和 `contains()`。

## array_append

`array_append()` 函数用于向目标数组中新增指定元素。语法如下：

```sql
array_append(arr1, element)
```

输入参数说明如下：

* `arr1` 为基础数组时，`element` 应为数组支持的基础类型，支持 Tinyint、Smallint、Int、Bigint、Float、Double、VarChar 类型。
* `arr1` 为嵌套数组时，`element` 应为数组，其嵌套层数应等于 `arr1` 的子数组的嵌套层数。

返回值为数组类型。

示例如下：

```sql
SELECT array_append([1,2,3], 2);
+--------------------------+
| array_append([1,2,3], 2) |
+--------------------------+
| [1,2,3,2]                |
+--------------------------+
1 row in set (0.001 sec)
```

```sql
SELECT array_append([1,2,3], -1);
+---------------------------+
| array_append([1,2,3], -1) |
+---------------------------+
| [1,2,3,-1]                |
+---------------------------+
1 row in set (0.001 sec)
```

```sql
SELECT array_append(["1", "2", "a"], "OceanBase");
+--------------------------------------------+
| array_append(["1", "2", "a"], "OceanBase") |
+--------------------------------------------+
| ["1","2","a","OceanBase"]                  |
+--------------------------------------------+
1 row in set (0.001 sec)
```

```sql
SELECT array_append([[1,2],[3,4]], [5]);
+----------------------------------+
| array_append([[1,2],[3,4]], [5]) |
+----------------------------------+
| [[1,2],[3,4],[5]]                |
+----------------------------------+
1 row in set (0.001 sec)
```

## array_distinct

`array_distinct()` 函数用于对目标数组进行去重操作。语法如下：

```sql
array_distinct(arr1)
```

输入参数说明如下：

* `arr1` 传入的类型必须是一个数组类型。

返回值为数组类型。

如果数组的元素类型不一致（如字符串型数组与数值型数组），会报错。

示例如下：

```sql
SELECT array_distinct([1,2,3,2,3]);
+-----------------------------+
| array_distinct([1,2,3,2,3]) |
+-----------------------------+
| [1,2,3]                     |
+-----------------------------+
1 row in set (0.001 sec)
```

```sql
SELECT array_distinct([null,2,3,null]);
+-----------------------------+
| array_distinct([null,2,3,null]) |
+---------------------------------+
| [NULL,2,3]                      |
+---------------------------------+
1 row in set (0.001 sec)
```

```sql
SELECT array_distinct([1,2,3,2.0]);
+-----------------------------+
| array_distinct([1,2,3,2.0]) |
+-----------------------------+
| [1,2,3]                     |
+-----------------------------+
1 row in set (0.001 sec)
```

```sql
SELECT array_distinct([1.1,2.2,3.3,2.2]);
+-------------------------------+
| array_distinct([1.1,2.2,3.3,2.2]) |
+-----------------------------------+
| [1.1,2.2,3.3]                     |
+-----------------------------------+
1 row in set (0.001 sec)
```

```sql
SELECT array_distinct(["hello", "hi", "hi"]);
+---------------------------------------+
| array_distinct(["hello", "hi", "hi"]) |
+---------------------------------------+
| ["hello","hi"]                        |
+---------------------------------------+
1 row in set (0.001 sec)
```

```sql
SELECT array_distinct([[1,2],[3,4], [3,4]]);
+--------------------------------------+
| array_distinct([[1,2],[3,4], [3,4]]) |
+--------------------------------------+
| [[1,2],[3,4]]                        |
+--------------------------------------+
1 row in set (0.001 sec)
```

```sql
SELECT array_distinct([["hello", "world"], ["hi", "what"], ["are you?"], ["are you?"]]);
+----------------------------------------------------------------------------------+
| array_distinct([["hello", "world"], ["hi", "what"], ["are you?"], ["are you?"]]) |
+----------------------------------------------------------------------------------+
| [["hello","world"],["hi","what"],["are you?"]]                                   |
+----------------------------------------------------------------------------------+
1 row in set (0.001 sec)
```

## array_remove

`array_remove()` 函数用于对目标数组进行删除指定元素操作。语法如下：

```sql
array_remove(arr1, element)
```

输入参数说明如下：

* `arr1` 为基础数组时，`element` 应为数组支持的基础类型，支持 Tinyint、Smallint、Int、Bigint、Float、Double、VarChar 类型。
* `arr1` 为嵌套数组时，`element` 应为数组，其嵌套层数应等于 `arr1` 的子数组的嵌套层数。

返回值为数组类型。

示例如下：

```sql
SELECT array_remove([1,2,3], 2);
+--------------------------+
| array_remove([1,2,3], 2) |
+--------------------------+
| [1,3]                    |
+--------------------------+
1 row in set (0.001 sec)
```

```sql
SELECT array_remove([1,2,3], 2.0);
+----------------------------+
| array_remove([1,2,3], 2.0) |
+----------------------------+
| [1,3]                      |
+----------------------------+
1 row in set (0.001 sec)
```

```sql
SELECT array_remove([1.1,2.2,3.3], 2.2);
+----------------------------------+
| array_remove([1.1,2.2,3.3], 2.2) |
+----------------------------------+
| [1.1,3.3]                        |
+----------------------------------+
1 row in set (0.001 sec)
```

```sql
SELECT array_remove(["hello", "hi"], "hi");
+-------------------------------------+
| array_remove(["hello", "hi"], "hi") |
+-------------------------------------+
| ["hello"]                           |
+-------------------------------------+
1 row in set (0.001 sec)
```

```sql
SELECT array_remove([[1,2],[3,4]], [3,4]);
+------------------------------------+
| array_remove([[1,2],[3,4]], [3,4]) |
+------------------------------------+
| [[1,2]]                            |
+------------------------------------+
1 row in set (0.001 sec)
```

```sql
SELECT array_remove([[1,2],[3,4]], [3.0,4.0]);
+----------------------------------------+
| array_remove([[1,2],[3,4]], [3.0,4.0]) |
+----------------------------------------+
| [[1,2]]                                |
+----------------------------------------+
1 row in set (0.001 sec)
```

```sql
SELECT array_remove([["hello", "world"], ["hi", "what"], ["are you?"]], ["are you?"]);
+--------------------------------------------------------------------------------+
| array_remove([["hello", "world"], ["hi", "what"], ["are you?"]], ["are you?"]) |
+--------------------------------------------------------------------------------+
| [["hello","world"],["hi","what"]]                                              |
+--------------------------------------------------------------------------------+
1 row in set (0.001 sec)
```

## cardinality

`cardinality()` 函数用于返回目标数组的基础元素数量。若目标数组为嵌套数组，则返回其所有非空子数组的基础元素数量之和。语法如下：

```sql
cardinality(arr1)
```

输入参数说明如下：

* `arr1` 传入的类型必须是一个数组类型。

返回值为整数类型。

示例如下：

```sql
SELECT cardinality([1,2,3]);
+----------------------+
| cardinality([1,2,3]) |
+----------------------+
|                    3 |
+----------------------+
1 row in set (0.001 sec)
```

```sql
SELECT cardinality([1,2,3,NULL]);
+----------------------------+
| cardinality([1,2,3,NULL]) |
+----------------------------+
|                        4 |
+----------------------------+
1 row in set (0.001 sec)
```

```sql
SELECT cardinality(['a','b','c','d']);
+----------------------------+
| cardinality(['a','b','c','d']) |
+----------------------------+
|                            4 |
+----------------------------+
1 row in set (0.001 sec)
```

```sql
SELECT cardinality([[1,2,3],[4]]);
+----------------------------+
| cardinality([[1,2,3],[4]]) |
+----------------------------+
|                          4 |
+----------------------------+
1 row in set (0.001 sec)
```

```sql
SELECT cardinality([['a','b',NULL,'c'],[NULL,'d']]);
+----------------------------------------------+
| cardinality([['a','b',NULL,'c'],[NULL,'d']]) |
+----------------------------------------------+
|                                            6 |
+----------------------------------------------+
1 row in set (0.001 sec)
```

```sql
SELECT cardinality([[1,2,3],NULL]);
+-----------------------------+
| cardinality([[1,2,3],NULL]) |
+-----------------------------+
|                           3 |
+-----------------------------+
1 row in set (0.001 sec)
```

## element_at

`element_at()` 函数根据索引，返回目标数组中指定位置的元素。语法如下：

```sql
element_at(arr1, index)
```

输入参数说明如下：

* `arr1` 传入的类型必须是一个数组类型。
* `index` 需要获取的子元素的位置，支持整数类型。

返回值说明如下：

* 若 `arr1` 为嵌套数组，返回类型为数组。
* 若 `arr1` 为基础类型，返回类型为相应的基础类型。

示例如下：

```sql
SELECT element_at([1,2,3], 2);
+------------------------+
| element_at([1,2,3], 2) |
+------------------------+
|                      2 |
+------------------------+
1 row in set (0.001 sec)
```

```sql
SELECT element_at([1,2,3], 4);
+------------------------+
| element_at([1,2,3], 4) |
+------------------------+
|                   NULL |
+------------------------+
1 row in set (0.001 sec)
```

```sql
SELECT element_at(['a',NULL,'bb','ccc'], 4);
+--------------------------------------+
| element_at(['a',NULL,'bb','ccc'], 4) |
+--------------------------------------+
| ccc                                  |
+--------------------------------------+
1 row in set (0.001 sec)
```

```sql
SELECT element_at([[1,2],[3,4]], 1);
+------------------------------+
| element_at([[1,2],[3,4]], 1) |
+------------------------------+
| [1,2]                        |
+------------------------------+
1 row in set (0.001 sec)
```

```sql
SELECT element_at([["hello", "world"], ["hi", "what"], ["are you?"]], 3);
+-------------------------------------------------------------------+
| element_at([["hello", "world"], ["hi", "what"], ["are you?"]], 3) |
+-------------------------------------------------------------------+
| ["are you?"]                                                      |
+-------------------------------------------------------------------+
1 row in set (0.001 sec)
```

## string_to_array

`string_to_array()` 函数用于将字符转换为数组。具体而言，即根据指定的分隔符和空元素符将输入的字符拆分成多个元素，再将元素依次放入一个数组中。分隔符和空元素符大小写敏感。语法如下：

```sql
string_to_array(arr_str, delimiter[, null_str])
```

输入参数说明如下：

* `arr_str` 传入的类型必须是一个字符类型，包含 Char、Varchar 类型。
* `delimiter` 分隔符，支持字符类型，包含 Char、Varchar 类型。
* `null_str`（可选） 空元素符，支持字符类型，包含 Char、Varchar 类型。

返回值为元素为字符的数组类型。

示例如下：

```sql
SELECT string_to_array('1and2and3and', 'and');
+----------------------------------------+
| string_to_array('1and2and3and', 'and') |
+----------------------------------------+
| ["1","2","3",""]                       |
+----------------------------------------+
1 row in set (0.001 sec)
```

```sql
SELECT string_to_array('1,2,3', '');
+------------------------------+
| string_to_array('1,2,3', '') |
+------------------------------+
| ["1,2,3"]                    |
+------------------------------+
1 row in set (0.001 sec)
```

```sql
SELECT string_to_array('1andNULLand3andNULL', 'and', 'NULL');
+-------------------------------------------------------+
| string_to_array('1andNULLand3andNULL', 'and', 'NULL') |
+-------------------------------------------------------+
| ["1",NULL,"3",NULL]                                   |
+-------------------------------------------------------+
1 row in set (0.001 sec)
```

## split

`split()` 函数用于将字符串 `string` 按分隔符 `delimiter` 进行分隔，并返回数组。语法如下：

```sql
split(string, delimiter)
```

参数说明如下：

* `string` 和 `delimiter` 均为 `VARCHAR`类型。

* 返回值类型为 `ARRAY<varchar>`。

示例如下：

```sql
SELECT split('1#2#3', '#'), split('#1#2#3#', '#'),  split('123', '#');
+---------------------+-----------------------+-------------------+
| split('1#2#3', '#') | split('#1#2#3#', '#') | split('123', '#') |
+---------------------+-----------------------+-------------------+
| ["1","2","3"]       | ["","1","2","3",""]   | ["123"]           |
+---------------------+-----------------------+-------------------+
```

## contains

`contains()` 函数用于检查某个元素是否存在于指定的容器或字符串中，并返回一个布尔值。语法如下：

```sql
CONTAINS(array_expr, value)
```

示例如下：

```sql
SELECT CONTAINS([1, 2, 3, 4, 5], 3), CONTAINS([1, 2, 3, 4, 5], 6), CONTAINS(['a', 'b', 'c'], 'b'), CONTAINS(['a', 'b', 'c'], 'd');
+------------------------------+------------------------------+--------------------------------+--------------------------------+
| CONTAINS([1, 2, 3, 4, 5], 3) | CONTAINS([1, 2, 3, 4, 5], 6) | CONTAINS(['a', 'b', 'c'], 'b') | CONTAINS(['a', 'b', 'c'], 'd') |
+------------------------------+------------------------------+--------------------------------+--------------------------------+
|                            1 |                            0 |                              1 |                              0 |
+------------------------------+------------------------------+--------------------------------+--------------------------------+
```

## array_agg

`array_agg()` 函数用于将指定列上的多行数据汇聚成 1 个数组值并返回结果。语法如下：

```sql
array_agg([DISTINCT] col [ORDER BY col0 [DESC | ASC] [NULLS FIRST | NULLS LAST] ...])
```

输入参数说明如下：

* `col` 聚合数据的目标列。
* `DISTINCT`（可选） 用于指定是否对 `col` 列进行去重操作。
* `ORDER BY`（可选） 用于指定是否对 `col` 列进行排序操作。
  * `DESC`（可选） 用于指定排序方向为降序。
  * `ASC`（可选） 用于指定排序方向为升序。
  * `NULLS FIRST`（可选） 用于指定在排序时将 `NULL` 值排在最前面。
  * `NULLS LAST`（可选） 用于指定在排序时将 `NULL` 值排在最后面。

返回值为数组类型。

约束如下：

* `ORDER BY` 指定的 `col0` 不支持数组类型。
* `ORDER BY` 不支持通过 `1, 2, ...` 等数字指定排序列，如果使用数字将会忽略 `ORDER BY`。

示例如下：

```sql
SELECT * FROM ss;
+------+------+-----------+-------+--------+
| id   | name | subject   | score | arr    |
+------+------+-----------+-------+--------+
|    1 | Tom  | English   |  90.5 | [1,2]  |
|    1 | Tom  | Math      |  80.8 | [1,2]  |
|    2 | Tom  | English   |  NULL | [1]    |
|    2 | Tom  | NULL      |  NULL | NULL   |
|    3 | May  | NULL      |  NULL | [2]    |
|    3 | Ti   | English   |  98.3 | [NULL] |
|    4 | NULL | NULL      |  NULL | NULL   |
| NULL | NULL | NULL      |  NULL | NULL   |
| NULL | Ti   | 物理Phy   |    99 | [3,4]  |
+------+------+-----------+-------+--------+
9 rows in set (0.001 sec)
```

```sql
SELECT array_agg(DISTINCT name ORDER BY name ASC), array_agg(name ORDER BY name DESC) FROM ss ORDER BY id;
+--------------------------------------------+-----------------------------------------------------+
| array_agg(distinct name order by name asc) | array_agg(name order by name desc)                  |
+--------------------------------------------+-----------------------------------------------------+
| [NULL,"May","Ti","Tom"]                    | ["Tom","Tom","Tom","Tom","Ti","Ti","May",NULL,NULL] |
+--------------------------------------------+-----------------------------------------------------+
1 row in set (0.001 sec)
```

```sql
SELECT array_agg(score ORDER BY score DESC NULLS FIRST), array_agg(score ORDER BY score DESC NULLS LAST) FROM ss ORDER BY id;
+--------------------------------------------------+-------------------------------------------------+
| array_agg(score order by score desc nulls first) | array_agg(score order by score desc nulls last) |
+--------------------------------------------------+-------------------------------------------------+
| [NULL,NULL,NULL,NULL,NULL,99,98.3,90.5,80.8]     | [99,98.3,90.5,80.8,NULL,NULL,NULL,NULL,NULL]    |
+--------------------------------------------------+-------------------------------------------------+
1 row in set (0.001 sec)
```

```sql
SELECT array_agg(arr ORDER BY id), array_agg(DISTINCT arr) FROM ss;
+---------------------------------------------------+-----------------------------------+
| array_agg(arr order by id)                        | array_agg(distinct arr)           |
+---------------------------------------------------+-----------------------------------+
| [NULL,[3,4],[1,2],[1,2],[1],NULL,[2],[NULL],NULL] | [[1,2],[1],NULL,[2],[NULL],[3,4]] |
+---------------------------------------------------+-----------------------------------+
1 row in set (0.001 sec)
```

## unnest

`unnest()` 函数用于将数组中的元素展开为多行，并返回一个包含这些元素的关系表。语法如下：

```sql
unnest(arr_list) [AS] [table_name[(col_name_list)]]
```

输入参数说明如下：

* `arr_list` 传入一个或多个数组值，之间用逗号分隔。
* `table_name` （可选） 用于指定返回的表名，默认值为 `unnest`。`AS` 关键字可省略，功能不变。
* `col_name_list` （可选） 用于分别指定返回的每个列的列名，默认值为 `unnest`，之间用逗号分隔。输入的列名数量必须与数组值数量一致。

返回值说明如下：

* 返回一个表，表的行数为输入的数组的最大元素数量，列数为输入的数组个数，数组元素较少的列，将用 `NULL` 补齐空行。
* 对于 n 层嵌套的数组，`unnest` 只解开第一层（即最外层）数组，即输出的结果为 n-1 层嵌套的数组。
* 第 n 行的内容为每个数组的第 n 个子元素。若 `arr_list` 的元素为基础数据类型，则输出类型为相应元素的类型。若元素为数组类型，则输出类型为数组类型。

约束如下：

* `unnest()` 函数只支持放在 `FROM` 子句后面。

示例如下：

```sql
SELECT * FROM unnest([1,2,3]);
+--------+
| unnest |
+--------+
|      1 |
|      2 |
|      3 |
+--------+
3 rows in set (0.001 sec)
```

```sql
SELECT * FROM unnest([1,2,NULL,3], ['11',NULL,'22']);
+--------+--------+
| unnest | unnest |
+--------+--------+
|      1 | 11     |
|      2 | NULL   |
|   NULL | 22     |
|      3 | NULL   |
+--------+--------+
4 rows in set (0.001 sec)
```

```sql
SELECT t.* FROM unnest([[1,2],[3],NULL,[4,5,6]]) AS t;
+---------+
| unnest  |
+---------+
| [1,2]   |
| [3]     |
| NULL    |
| [4,5,6] |
+---------+
4 rows in set (0.001 sec)
```

```sql
SELECT t.* FROM unnest([[1,2],[3],NULL,[4,5,6]], ['hi','hello']) AS t(c1,c2);
+---------+-------+
| c1      | c2    |
+---------+-------+
| [1,2]   | hi    |
| [3]     | hello |
| NULL    | NULL  |
| [4,5,6] | NULL  |
+---------+-------+
4 rows in set (0.001 sec)
```

```sql
SELECT * FROM unnest([1,2,3]) t1(c1), unnest(['11','22']) AS t2(c2);
+------+------+
| c1   | c2   |
+------+------+
|    1 | 11   |
|    1 | 22   |
|    2 | 11   |
|    2 | 22   |
|    3 | 11   |
|    3 | 22   |
+------+------+
6 rows in set (0.001 sec)
```

## array_prepend

`array_prepend()` 函数用于在数组的开头添加一个元素，并返回一个新的数组。语法如下：

```sql
array_prepend(array, element)
```

输入参数说明如下：

* `array` 传入一个数组值。
* `element` 传入新增的目标元素，需与 `array` 参数的数组元素类型一致。

返回值为数组类型。

示例如下：

```sql
SELECT array_prepend([1,2,3], 2);
+--------------------------------+
| array_prepend([1,2,3], 2)   |
+--------------------------------+
| [2,1,2,3]                    |
+--------------------------------+
1 row in set (0.001 sec)
```

```sql
SELECT array_prepend([1,2,3], NULL);
+------------------------------+
| array_prepend([1,2,3], NULL) |
+------------------------------+
| [NULL,1,2,3]                 |
+------------------------------+
1 row in set (0.001 sec)
```

```sql
SELECT array_prepend(["1", "2", "a"], "OceanBase");
+---------------------------------------------+
| array_prepend(["1", "2", "a"], "OceanBase") |
+---------------------------------------------+
| ["OceanBase","1","2","a"]                   |
+---------------------------------------------+
1 row in set (0.001 sec)
```

## array_concat

`array_concat()` 函数用于将多个数组合并，并返回一个新的数组。语法如下：

```sql
array_concat(array_list)
```

输入参数说明如下：

* `array_list` 传入一个或多个数组值。

返回值为数组类型。

约束如下：

* 支持嵌套数组合并，但要求每个数组的嵌套层数相同，返回结果为第一层（即最外层）元素的合并结果。

示例如下：

```sql
SELECT array_concat([1,2,3], [4,5,6]);
+--------------------------------+
| array_concat([1,2,3], [4,5,6]) |
+--------------------------------+
| [1,2,3,4,5,6]                 |
+--------------------------------+
1 row in set (0.001 sec)
```

```sql
SELECT array_concat([1,2,3], [-4], [5.5,6]);
+--------------------------------------+
| array_concat([1,2,3], [-4], [5.5,6]) |
+--------------------------------------+
| [1,2,3,-4,5.5,6]                     |
+--------------------------------------+
1 row in set (0.001 sec)
```

```sql
SELECT array_concat([[1,2,3]],[[11],[22,44]]);
+----------------------------------------+
| array_concat([[1,2,3]],[[11],[22,44]]) |
+----------------------------------------+
| [[1,2,3],[11],[22,44]]                 |
+----------------------------------------+
1 row in set (0.001 sec)
```

## array_compact

`array_compact()` 函数用于删除数组中连续重复的元素，并返回一个新的数组。语法如下：

```sql
array_compact(array)
```

输入参数说明如下：

* `array` 传入一个数组值。

返回值为数组类型。

示例如下:

```sql
SELECT array_compact([1,2,2,3,3,2]);
+------------------------------+
| array_compact([1,2,2,3,3,2]) |
+------------------------------+
| [1,2,3,2]                    |
+------------------------------+
1 row in set (0.001 sec)
```

```sql
SELECT array_compact(["hello","hello",NULL,NULL,"OceanBase"]);
+--------------------------------------------------------+
| array_compact(["hello","hello",NULL,NULL,"OceanBase"]) |
+--------------------------------------------------------+
| ["hello",NULL,"OceanBase"]                             |
+--------------------------------------------------------+
1 row in set (0.001 sec)
```

```sql
SELECT array_compact([[1,2,3,NULL],[4,NULL],[4,NULL]]);
+-------------------------------------------------+
| array_compact([[1,2,3,NULL],[4,NULL],[4,NULL]]) |
+-------------------------------------------------+
| [[1,2,3,NULL],[4,NULL]]                         |
+-------------------------------------------------+
1 row in set (0.001 sec)
```

## array_sort

`array_sort()` 函数用于对数组进行升序排序，并且在排序时将 `NULL` 值放在数组的最后。语法如下：

```sql
array_sort(arr)
```

输入参数说明如下：

* `arr` 传入一个数组值。

返回值为数组类型。

示例如下：

```sql
SELECT array_sort([2,1,3]);
+---------------------+
| array_sort([2,1,3]) |
+---------------------+
| [1,2,3]             |
+---------------------+
1 row in set (0.001 sec)
```

```sql
SELECT array_sort([NULL,1,2,NULL,2,NULL,NULL]);
+-----------------------------------------+
| array_sort([NULL,1,2,NULL,2,NULL,NULL]) |
+-----------------------------------------+
| [1,2,2,NULL,NULL,NULL,NULL]             |
+-----------------------------------------+
1 row in set (0.001 sec)
```

```sql
SELECT array_sort(["hello","hello",NULL,NULL,"OceanBase"]);
+-----------------------------------------------------+
| array_sort(["hello","hello",NULL,NULL,"OceanBase"]) |
+-----------------------------------------------------+
| ["OceanBase","hello","hello",NULL,NULL]             |
+-----------------------------------------------------+
1 row in set (0.001 sec)
```

## array_length

`array_length()` 函数用于返回数组的长度。如果是嵌套数组，返回的是第一层（即最外层）数组的长度。语法如下：

```sql
array_length(arr)
```

输入参数说明如下：

* `arr` 传入一个数组值。支持嵌套数组。

返回值为 unit32 无符号整数类型。

示例如下：

```sql
SELECT array_length([1,2,3]);
+-----------------------+
| array_length([1,2,3]) |
+-----------------------+
|                     3 |
+-----------------------+
1 row in set (0.001 sec)
```

```sql
SELECT array_length([[1],[2,3]]);
+---------------------------+
| array_length([[1],[2,3]]) |
+---------------------------+
|                         2 |
+---------------------------+
1 row in set (0.001 sec)
```

## array_range

`array_range()` 函数用于生成一个等差数列数组。语法如下：

```sql
array_range(end)
array_range(start, end)
array_range(start, end, step)
```

输入参数说明如下：

* `start` 开始值，默认值为 `0`。
* `end` 结束值，仅支持整数类型。
* `step` 步长，仅支持整数类型，默认值为 `1`。

返回 BIGINT 元素的数组类型。输出的结果包含输入的 `start` 值，不包含 `end` 值。当 `(end - start)` / `step <= 0` 时，返回空数组。

具体说明如下：

* 生成的数组：`array_range` 会生成一个包含连续整数的数组，其中包含 `start` 元素，但不包括 `end` 元素。这意味着生成的数组的起始值是 `start`，而结束值是 `end`，但 `end` 本身不会被包含在结果中。
* 步长：如果提供了步长参数（step），则生成的数组中的每个元素将比前一个元素大 `step`。例如，如果 `start` 是 `1`，`end` 是 `10`，`step` 是 `2`，生成的数组将是 `[1, 3, 5, 7, 9]`。
* 返回空数组的条件：当 `(end - start)` / `step <= 0` 时，函数将返回一个空数组。这意味着如果 `end` 小于或等于 `start`，或者步长 `step` 为零或负数，生成的数组将没有有效的元素，因此返回空数组。

示例如下：

```sql
SELECT array_range(5);
+----------------+
| array_range(5) |
+----------------+
| [0,1,2,3,4]  |
+----------------+
1 row in set (0.001 sec)
```

```sql
SELECT array_range(-1,4);
+-------------------+
| array_range(-1,4) |
+-------------------+
| [-1,0,1,2,3]      |
+-------------------+
1 row in set (0.001 sec)
```

```sql
SELECT array_range(-1,4,2);
+---------------------+
| array_range(-1,4,2) |
+---------------------+
| [-1,1,3]            |
+---------------------+
1 row in set (0.001 sec)
```

## array_sum

`array_sum()` 函数用于计算数组中所有元素的总和。语法如下：

```sql
array_sum(arr)
```

输入参数说明如下：

* `arr` 传入一个数值元素类型的数组值。
* 对 `NULL` 值的处理：
  * 数组元素全为 `NULL`，则返回 `NULL`。
  * 数组元素非全 `NULL`，则将 `NULL` 值等同为 `0` 参与计算。

返回值说明如下：

* 返回整型（INT）元素的数组类型。
* 或返回浮点型（DOUBLE）元素的数组类型。

功能约束限制如下：

* 数组元素仅支持为整型（包括 INT，BIGINT 等）和浮点型（包括 FLOAT 和 DOUBLE）数值类型。
* 不支持嵌套数组。

示例如下：

```sql
SELECT array_sum([1,2,3]);
+--------------------+
| array_sum([1,2,3]) |
+--------------------+
|                  6 |
+--------------------+
1 row in set (0.001 sec)
```

```sql
SELECT array_sum([1,2.2,3]);
+----------------------+
| array_sum([1,2.2,3]) |
+----------------------+
|                  6.2 |
+----------------------+
1 row in set (0.001 sec)
```

## array_difference

`array_difference()` 函数用于计算数组中两个相邻元素的差值，并将结果存储在一个新的数组中返回。语法如下：

```sql
array_difference(arr)
```

输入参数说明如下：

* `arr` 传入的类型必须是一个数组类型。

返回值为数组类型。

功能约束限制如下：

* 数组元素仅支持为整型（包括 INT，BIGINT 等）和浮点型（包括 FLOAT 和 DOUBLE）数值类型。
* 不支持嵌套数组。

具体说明如下：

* 计算方式：
  * 返回数组中的第一个元素固定为 `0`。
  * 返回数组中的第 n 个元素的值为` array[n] - array[n-1]`，即当前元素减去前一个元素。
* 返回值：
  * 返回一个新的数组，其中第一个元素为 `0`，后续元素为相邻元素的差值。

示例如下：

```sql
SELECT array_difference([1,5,3]);
+---------------------------+
| array_difference([1,5,3]) |
+---------------------------+
| [0,4,-2]                  |
+---------------------------+
1 row in set (0.001 sec)
```

```sql
SELECT array_difference([1.1,2.2,4.4]);
+---------------------------------+
| array_difference([1.1,2.2,4.4]) |
+---------------------------------+
| [0,1.1,2.2]                     |
+---------------------------------+
1 row in set (0.001 sec)
```

## array_min

`array_min()` 函数用于返回数组中的最小值。语法如下：

```sql
array_min(arr)
```

输入参数说明如下：

* `arr` 传入的类型必须是一个数组类型。
* 对 `NULL` 值的处理：
  * 数组元素全为 `NULL`，则返回 `NULL`。
  * 数组元素非全 `NULL`，则跳过 `NULL` 元素。

返回值为输入的数组元素类型。

功能约束限制如下：

* 不支持嵌套数组。

示例如下：

```sql
SELECT array_min([1,2,4]);
+--------------------+
| array_min([1,2,4]) |
+--------------------+
|                  1 |
+--------------------+
1 row in set (0.001 sec)
```

```sql
SELECT array_min([1.1,2.2,4.4]);
+--------------------------+
| array_min([1.1,2.2,4.4]) |
+--------------------------+
|                      1.1 |
+--------------------------+
1 row in set (0.001 sec)
```

```sql
SELECT array_min([1,2,NULL,3]);
+-------------------------+
| array_min([1,2,NULL,3]) |
+-------------------------+
|                       1 |
+-------------------------+
1 row in set (0.001 sec)
```

## array_max

`array_max()` 函数用于返回数组中的最大值。语法如下:

```sql
array_max(arr)
```

输入参数说明如下:

* `arr` 传入的类型必须是一个数组类型。
* 对 `NULL` 值的处理：
  * 数组元素全为 `NULL`，则返回 `NULL`。
  * 数组元素非全 `NULL`，则跳过 `NULL` 元素。

返回值为输入的数组元素类型。

功能约束限制如下:

* 不支持嵌套数组.

示例如下:

```sql
SELECT array_max([1,2,4]);
+--------------------+
| array_max([1,2,4]) |
+--------------------+
|                  4 |
+--------------------+
1 row in set (0.001 sec)
```

```sql
SELECT array_max([1.1,2.2,4.4]);
+--------------------------+
| array_max([1.1,2.2,4.4]) |
+--------------------------+
|                      4.4 |
+--------------------------+
1 row in set (0.001 sec)
```

```sql
SELECT array_max([1,2,NULL,3]);
+-------------------------+
| array_max([1,2,NULL,3]) |
+-------------------------+
|                       3 |
+-------------------------+
1 row in set (0.001 sec)
```

## array_avg

`array_avg()` 函数用于返回数组中所有元素的平均值。语法如下：

```sql
array_avg(arr)
```

输入参数说明如下：

* `arr` 传入的类型必须是一个数组类型。
* 对 `NULL` 值的处理：
  * 数组元素全为 `NULL`，则返回 `NULL`。
  * 数组元素非全 `NULL`，则将 `NULL` 值等同为 `0` 参与计算。

返回值为浮点型（DOUBLE）元素的数组类型。

功能约束限制如下：

* 数组元素仅支持为整型（包括 INT，BIGINT 等）和浮点型（包括 FLOAT 和 DOUBLE）数值类型。
* 不支持嵌套数组。

示例如下：

```sql
SELECT array_avg([1,2,-4]);
+---------------------+
| array_avg([1,2,-4]) |
+---------------------+
| -0.3333333333333333 |
+---------------------+
1 row in set (0.001 sec)
```

```sql
SELECT array_avg([1,2,NULL,3]);
+-------------------------+
| array_avg([1,2,NULL,3]) |
+-------------------------+
|                     1.5 |
+-------------------------+
1 row in set (0.001 sec)
```

## array_position

`array_position()` 函数用于查找数组中指定元素的位置。语法如下：

```sql
array_position(arr, element)
```

输入参数说明如下：

* `arr` 传入的类型必须是一个数组类型。
* `element` 要查找的元素，支持数组支持的基础类型和数组类型。

返回值为整型（INT）元素的数组类型，若不存在该元素，返回 `0`。

示例如下：

```sql
SELECT array_position([1,2,3], 2);
+--------------------------------+
| array_position([1,2,3], 2)     |
+--------------------------------+
|                              2 |
+--------------------------------+
1 row in set (0.001 sec)
```

```sql
SELECT array_position(["hello", "hi"], "hi");
+---------------------------------------+
| array_position(["hello", "hi"], "hi") |
+---------------------------------------+
|                                     2 |
+---------------------------------------+
1 row in set (0.001 sec)
```

```sql
SELECT array_position(["hello", "hi"], "hel");
+----------------------------------------+
| array_position(["hello", "hi"], "hel") |
+----------------------------------------+
|                                      0 |
+----------------------------------------+
1 row in set (0.001 sec)
```

## array_slice

`array_slice()` 函数用于从数组的指定位置开始提取一部分元素，并将提取的元素组成新的数组返回。语法如下：

```sql
array_slice(arr, offset, length)
```

输入参数说明如下：

* `arr` 传入的类型必须是一个数组类型。
* `offset` 表示开始提取的元素位置：
  * 输入正数时表示从左往右数的第 `offset` 个元素开始提取。
  * 输入负数时为从右往左数的第 `-offset` 个。
* `length` 表示长度限制（可选参数）：
  * 输入正数时表示最多可以提取的元素个数。
  * 输入为负数时表示提取的右边界，即从右向左数的第 `-length` 个值。
  * 不填时为从 `offset` 开始的所有元素。

返回值说明如下：

* 返回值为数组类型。
* 当 `offset>数组长度` 或 `offset=0` 时，返回空数组。

示例如下：

```sql
-- offset 为正数，表示从左数的第 2 位，即从 2 开始提取
SELECT array_slice([1,2,3,4,5,6,7,8,9],2);
+------------------------------------+
| array_slice([1,2,3,4,5,6,7,8,9],2) |
+------------------------------------+
| [2,3,4,5,6,7,8,9]                  |
+------------------------------------+
1 row in set (0.001 sec)
```

```sql
-- offset 为正数，表示从左数的第 10 位，此时 offset 大于数组长度，返回空数组
SELECT array_slice([1,2,3,4,5,6,7,8,9],10);
+-------------------------------------+
| array_slice([1,2,3,4,5,6,7,8,9],10) |
+-------------------------------------+
| []                                  |
+-------------------------------------+
1 row in set (0.001 sec)
```

```sql
-- offset 为 0，返回空数组
SELECT array_slice([1,2,3,4,5,6,7,8,9],0);
+------------------------------------+
| array_slice([1,2,3,4,5,6,7,8,9],0) |
+------------------------------------+
| []                                 |
+------------------------------------+
1 row in set (0.001 sec)
```

```sql
-- offset 为负数表示从右数的第 2 位，即从 8 开始提取
SELECT array_slice([1,2,3,4,5,6,7,8,9],-2);
+-------------------------------------+
| array_slice([1,2,3,4,5,6,7,8,9],-2) |
+-------------------------------------+
| [8,9]                               |
+-------------------------------------+
1 row in set (0.001 sec)
```

```sql
-- length 为正数，表示提取 2 个元素
SELECT array_slice([1,2,3,4,5,6,7,8,9],2,2);
+--------------------------------------+
| array_slice([1,2,3,4,5,6,7,8,9],2,2) |
+--------------------------------------+
| [2,3]                                |
+--------------------------------------+
1 row in set (0.001 sec)
```

```sql
-- length 为正数，表示取 10 个元素，超出右边界
SELECT array_slice([1,2,3,4,5,6,7,8,9],2,10);
+---------------------------------------+
| array_slice([1,2,3,4,5,6,7,8,9],2,10) |
+---------------------------------------+
| [2,3,4,5,6,7,8,9]                     |
+---------------------------------------+
1 row in set (0.001 sec)
```

```sql
-- length 为 -2，表示从右数 2 个不取，即 8，9 不取
SELECT array_slice([1,2,3,4,5,6,7,8,9],2,-2);
+---------------------------------------+
| array_slice([1,2,3,4,5,6,7,8,9],2,-2) |
+---------------------------------------+
| [2,3,4,5,6,7]                         |
+---------------------------------------+
1 row in set (0.001 sec)
```

```sql
-- length 为 -10，表示从右数 10 个不取，此时超出了左边界，返回空数组
SELECT array_slice([1,2,3,4,5,6,7,8,9],2,-10);
+----------------------------------------+
| array_slice([1,2,3,4,5,6,7,8,9],2,-10) |
+----------------------------------------+
| []                                     |
+----------------------------------------+
1 row in set (0.001 sec)
```

```sql
-- offset 为 -10，表示从右数第 10 个位置开始提取，此时超出左边界 1 位，从该位置开始取 length（4）位
SELECT array_slice([1,2,3,4,5,6,7,8,9],-10,4);
+----------------------------------------+
| array_slice([1,2,3,4,5,6,7,8,9],-10,4) |
+----------------------------------------+
| [1,2,3]                                |
+----------------------------------------+
1 row in set (0.001 sec)
```

```sql
-- offset 为 -6，表示从右数第 6 个位置开始提取，即 4；length 为 -4，表示从右数 4 个不取，即 6，7，8，9 不取
SELECT array_slice([1,2,3,4,5,6,7,8,9],-6,-4);
+-----------------------------------------+
| array_slice([1,2,3,4,5,6,7,8,9],-6,-4) |
+-----------------------------------------+
| [4,5]                             |
+-----------------------------------------+
1 row in set (0.001 sec)
```

## reverse

`reverse()` 函数用于逆序排列数组中的元素。如果是嵌套数组，则逆序排列最内层的元素。语法如下：

```sql
reverse(arr)
```

输入参数说明如下：

* `arr` 传入的类型必须是一个数组类型。支持嵌套数组。

返回值为数组类型。

示例如下：

```sql
SELECT reverse([1,2,3]);
+----------------+
| reverse([1,2,3]) |
+----------------+
| [3,2,1]         |
+----------------+
1 row in set (0.001 sec)
```

```sql
SELECT reverse([['a'], ['b'], ['c']]) ;
+--------------------------------+
| reverse([['a'], ['b'], ['c']]) |
+--------------------------------+
| [["c"],["b"],["a"]]            |
+--------------------------------+
1 row in set (0.001 sec)
```

## array_map

`array_map()` 函数用于将输入的每个数组的元素按照 Lambda 函数进行转换，并将每次转换后得到的所有新元素合成 1 个新的数组作为输出结果。语法如下：

```sql
arrayMap((x1,...,xn) -> (expression), arr1,...,arrn)
```

输入参数说明如下：

* `(x1,...,xn) -> (expression)` Lambda 函数。Lambda 函数是一种匿名函数，在定义时不需要使用常规的 `def` 语句，而是使用 `lambda` 关键字来创建。Lambda 函数可以接受任意数量的参数，但只能有一个表达式。
* `arr1,...,arrn` 输入的数组。传入的类型必须是一个数组类型，数组元素个数必须是一样的；`n` 必须和 Lambda 函数参数个数一致。
* 依次取出每个输入数组的第 i 个元素作为 Lambda 函数的输入参数，返回值作为新数组的第 i 个元素。

返回值为数组类型，元素类型为 Lambda 值的返回类型，数组长度为传入数组的元素个数。

功能约束限制如下：

* Lambda 函数的 `expression` 不支持子查询语句。
* Lambda 函数的 `expression` 不支持汇聚函数。
* Lambda 函数的 `expression` 不支持作为生成列的表达式。

示例如下：

```sql
SELECT array_map((x,y,z) -> (x is null and y is not null or z is not null), [[1]], [1],['abc']);
+------------------------------------------------------------------------------------------+
| array_map((x,y,z) -> (x is null and y is not null or z is not null), [[1]], [1],['abc']) |
+------------------------------------------------------------------------------------------+
| [1]                                                                                      |
+------------------------------------------------------------------------------------------+
1 row in set (0.001 sec)
```

```sql
SELECT array_map((x,y) -> (x + y),[1], [2]);
+--------------------------------------+
| array_map((x,y) -> (x + y),[1], [2]) |
+--------------------------------------+
| [3]                                  |
+--------------------------------------+
1 row in set (0.001 sec)
```

```sql
SELECT array_map((x,y)->((x is null) and (y is null)), [1232], [[['abc']]]);
+----------------------------------------------------------------------+
| array_map((x,y)->((x is null) and (y is null)), [1232], [[['abc']]]) |
+----------------------------------------------------------------------+
| [0]                                                                  |
+----------------------------------------------------------------------+
1 row in set (0.001 sec)
```

```sql
SELECT array_map((x,y)->(x+y), array_map(x2->(x2+1),[1,2,3]),array_map(x1->(x1+2),[1,2,3]));
+--------------------------------------------------------------------------------------+
| array_map((x,y)->(x+y), array_map(x2->(x2+1),[1,2,3]),array_map(x1->(x1+2),[1,2,3])) |
+--------------------------------------------------------------------------------------+
| [5,7,9]                                                                              |
+--------------------------------------------------------------------------------------+
1 row in set (0.001 sec)
```

```sql
SELECT array_map(x ->(length(x)), ['abc', 'efgaa']);
+----------------------------------------------+
| array_map(x ->(length(x)), ['abc', 'efgaa']) |
+----------------------------------------------+
| [3,5]                                        |
+----------------------------------------------+
1 row in set (0.001 sec)
```

```sql
SELECT array_map((x, y)->(floor((y - x) / x)), [4, 5, 6], [3,8,5]);
+-------------------------------------------------------------+
| array_map((x, y)->(floor((y - x) / x)), [4, 5, 6], [3,8,5]) |
+-------------------------------------------------------------+
| [-1,0,-1]                                                   |
+-------------------------------------------------------------+
1 row in set (0.001 sec)
```

## array_filter

`array_filter()` 根据 Lambda 函数的返回值过滤 `arr1` 数组的元素。若 Lambda 函数返回值为 `0` 或者 `NULL`，则过滤掉相应的 `arr1` 元素，并返回一个新的数组。语法如下：

```sql
array_filter((x1,...,xn) -> (expression), arr1,...,arrn)
```

输入参数说明如下：

* `(x1,...,xn) -> (expression)` Lambda 函数。Lambda 函数是一种匿名函数，在定义时不需要使用常规的 `def` 语句，而是使用 `lambda` 关键字来创建。Lambda 函数可以接受任意数量的参数，但只能有一个表达式。
* `arr1,...,arrn` 输入的数组。传入的类型必须是一个数组类型，数组元素个数必须是一样的；`n` 必须和 Lambda 函数参数个数一致。支持嵌套数组。

返回值为数组类型，即过滤后的 `arr1` 数组。

功能约束限制如下：

* 仅支持 Lambda 函数的返回值为整型或 `NULL`。

示例如下：

```sql
SELECT array_filter(x ->(x + 1 > 2),[1,2,3,4]);
+-----------------------------------------+
| array_filter(x ->(x + 1 > 2),[1,2,3,4]) |
+-----------------------------------------+
| [2,3,4]                                 |
+-----------------------------------------+
1 row in set (0.001 sec)
```

```sql
SELECT array_filter((x, y) ->(y), [1,2,3,4,5], [NULL,1,-1,0,2]);
+----------------------------------------------------------+
| array_filter((x, y) ->(y), [1,2,3,4,5], [NULL,1,-1,0,2]) |
+----------------------------------------------------------+
| [2,3,5]                                                  |
+----------------------------------------------------------+
1 row in set (0.001 sec)
```

```sql
SELECT array_filter((x, y) ->(y), [['a'],['b','c'],['d']], [1,0,1]);
+--------------------------------------------------------------+
| array_filter((x, y) ->(y), [['a'],['b','c'],['d']], [1,0,1]) |
+--------------------------------------------------------------+
| [["a"],["d"]]                                                |
+--------------------------------------------------------------+
1 row in set (0.001 sec)
```

## array_sortby

`array_sortby()` 函数根据给定的 Lambda 函数对一个数组进行排序。语法如下：

```sql
array_sortby((x1,...,xn) -> (expression), arr1,...,arrn)
```

输入参数说明如下：

* `(x1,...,xn) -> (expression)` Lambda 函数。Lambda 函数是一种匿名函数，在定义时不需要使用常规的 `def` 语句，而是使用 `lambda` 关键字来创建。Lambda 函数可以接受任意数量的参数，但只能有一个表达式。
* `arr1,...,arrn` 输入的数组。传入的类型必须是一个数组类型，数组元素个数必须是一样的；`n` 必须和 Lambda 函数参数个数一致。支持嵌套数组。

返回值为数组类型。

功能约束限制如下：

* 仅支持 Lambda 函数的返回值只能为数组支持的基础元素类型，不支持为数组类型。

具体工作流程如下：

1. 生成排序依据：首先，`array_sortby` 会根据提供的 Lambda 函数对输入数组的每个元素进行计算，生成一个新的数组，这个数组包含了每个元素经过 Lambda 函数处理后的结果。
2. 升序排序及处理 `NULL` 值：接下来，对这个新生成的数组进行升序排序，同时将 `NULL` 值放在最后。这意味着在排序时，所有非 `NULL` 的值会被优先考虑，而 `NULL` 值会被放置在排序结果的末尾。
3. 根据排序顺序重新排序原数组：最后，`array_sortby` 会根据新生成数组的排序顺序，对原数组进行排序。这意味着原数组中的元素会按照 Lambda 函数计算结果的排序顺序进行排列。
4. 返回排序后的数组：最终，函数返回经过排序的原数组。

示例如下：

```sql
SELECT array_sortby(x ->(x), [4,2,1,3]);
+----------------------------------+
| array_sortby(x ->(x), [4,2,1,3]) |
+----------------------------------+
| [1,2,3,4]                        |
+----------------------------------+
1 row in set (0.001 sec)
```

```sql
SELECT array_sortby(x ->(x), ['c',NULL,'a',NULL]);
+--------------------------------------------+
| array_sortby(x ->(x), ['c',NULL,'a',NULL]) |
+--------------------------------------------+
| ["a","c",NULL,NULL]                        |
+--------------------------------------------+
1 row in set (0.001 sec)
```

```sql
SELECT array_sortby((x,y) ->(y),['a','b','c'], [2,1,3]);
+--------------------------------------------------+
| array_sortby((x,y) ->(y),['a','b','c'], [2,1,3]) |
+--------------------------------------------------+
| ["b","a","c"]                                    |
+--------------------------------------------------+
1 row in set (0.001 sec)
```

```sql
SELECT array_sortby((x,y) ->(y),[['a'],['b'],['c']], [2,1,3]);
+--------------------------------------------------------+
| array_sortby((x,y) ->(y),[['a'],['b'],['c']], [2,1,3]) |
+--------------------------------------------------------+
| [["b"],["a"],["c"]]                                    |
+--------------------------------------------------------+
1 row in set (0.001 sec)
```

## array_first

`array_first()` 函数用于返回 `arr1` 数组中第一个使得给定的 Lambda 函数返回值不为 `0` 的元素。语法如下：

```sql
array_first(（x1,...,xn) -> (expression), array1,...,arrayn)
```

输入参数说明如下：

* `(x1,...,xn) -> (expression)` 提供一个 Lambda 函数。
* `arr1,...,arrn` 输入的数组。传入的类型必须是一个数组类型，数组元素个数必须是一样的；`n` 必须和 Lambda 函数参数个数一致。支持嵌套数组。

返回值为任意元素类型。

具体说明如下：

* Lambda 函数：你需要提供一个 Lambda 函数，该函数会对数组中的每个元素进行评估。Lambda 函数的返回值必须是整型。
* 数组支持嵌套：`array_first` 函数支持嵌套数组，这意味着你可以传入一个包含其他数组的数组。
* 返回值：函数会遍历 `arr1` 中的元素，找到第一个使得 Lambda 函数返回值不为 `0` 的元素，并将其作为结果返回。如果没有任何元素使得 Lambda 函数返回非零值，则可能返回 `NULL`。

示例如下：

```sql
SELECT array_first(x ->(x + 1 > 2),[1,2,3,4]);
+----------------------------------------+
| array_first(x ->(x + 1 > 2),[1,2,3,4]) |
+----------------------------------------+
|                                      2 |
+----------------------------------------+
1 row in set (0.001 sec)
```

```sql
SELECT array_first((x,y) ->(y),[[1],[2],[3]], [0,1,3]);
+-------------------------------------------------+
| array_first((x,y) ->(y),[[1],[2],[3]], [0,1,3]) |
+-------------------------------------------------+
| [2]                                             |
+-------------------------------------------------+
1 row in set (0.001 sec)
```

示例说明如下：

* Lambda 函数：`(x,y) -> (y)` 是一个 Lambda 函数，它接受两个参数 `x` 和 `y`，并返回 `y` 的值。这里的 `x` 其实在这个特定的调用中并没有被使用。
* 输入数组：
  * `[[1],[2],[3]]` 是一个嵌套数组，其中包含三个子数组。
  * `[0,1,3]` 是一个一维数组，包含三个整数。
* 返回值的计算：
  * `array_first` 函数会遍历输入的数组 `[[1],[2],[3]]` 中的每个元素，并对每个元素调用 Lambda 函数，使用对应的 `y` 值（来自 `[0,1,3]`）进行评估。
  * 在这个例子中，Lambda 函数的返回值为 `0`、`1` 和 `3`，分别对应于 `0`（对于 `[1]`）、`1`（对于 `[2]`）和 `3`（对于 `[3]`）。
  * 因此，`array_first` 会找到 `[[1],[2],[3]]` 中第一个使得 Lambda 函数返回值不为 `0` 的元素。在这里，`[2]` 对应的 `y` 值是 `1`，这是第一个非零值。最终返回值为 `[2]`。

## array_except

`array_except()` 函数用于返回属于 `arr1` 但不属于 `arr2` 的元素组成的数组。语法如下：

```sql
array_except(arr1, arr2)
```

输入参数说明如下：

* `arr1`：需要计算的左数组。
* `arr2`：需要计算的右数组。

返回值为数组类型。

具体说明如下：

* 数组支持嵌套：输入的数组可以是嵌套数组，但要求所有数组的嵌套层数一致，当数组为嵌套数组时，参与运算的元素为第一层数组，即使两个数组的元素相同但顺序不同，也会被视为不同的数组。
* `NULL` 值处理：数组元素中如果有一个为 `NULL`，结果返回 `NULL`。

示例如下：

```sql
SELECT array_except([1,2,3], [1,2]);
+------------------------------+
| array_except([1,2,3], [1,2]) |
+------------------------------+
| [3]                          |
+------------------------------+
1 row in set (0.001 sec)
```

```sql
SELECT array_except(["test", "array"], ["test"]);
+-------------------------------------------+
| array_except(["test", "array"], ["test"]) |
+-------------------------------------------+
| ["array"]                                 |
+-------------------------------------------+
1 row in set (0.001 sec)
```

```sql
SELECT array_except([[1,2,3],[1,2]], [[1,2],[3,4]]);
+----------------------------------------------+
| array_except([[1,2,3],[1,2]], [[1,2],[3,4]]) |
+----------------------------------------------+
| [[1,2,3]]                                    |
+----------------------------------------------+
1 row in set (0.001 sec)
```

```sql
SELECT array_except([1,2,3,NULL], [1]);
+---------------------------------+
| array_except([1,2,3,NULL], [1]) |
+---------------------------------+
| [2,3,NULL]                      |
+---------------------------------+
1 row in set (0.001 sec)
```

## array_intersect

`array_intersect()` 函数用于计算所有输入数组的第一层元素的交集。语法如下：

```sql
array_intersect(arr_list)
```

输入参数说明如下：

* `arr_list`：需要进行交集运算的数组列表。

返回值为数组类型。

具体说明如下：

* 数组支持嵌套：输入的数组可以是嵌套数组，但要求所有数组的嵌套层数一致，当数组为嵌套数组时，参与运算的元素为第一层数组，即使两个数组的元素相同但顺序不同，也会被视为不同的数组。
* `NULL` 值处理：无特殊处理。

示例如下：

```sql
SELECT array_intersect([1,2,3], [1,2]);
+---------------------------------+
| array_intersect([1,2,3], [1,2]) |
+---------------------------------+
| [1,2]                           |
+---------------------------------+
1 row in set (0.001 sec)
```

```sql
-- 计算结果会自动去重
SELECT array_intersect([1,1,2,2,3], [1,1,2]);
+---------------------------------------+
| array_intersect([1,1,2,2,3], [1,1,2]) |
+---------------------------------------+
| [1,2]                                 |
+---------------------------------------+
1 row in set (0.001 sec)
```

```sql
SELECT array_intersect([1,2,4,NULL], [4,5,NULL]);
+-------------------------------------------+
| array_intersect([1,2,4,NULL], [4,5,NULL]) |
+-------------------------------------------+
| [4,NULL]                                  |
+-------------------------------------------+
1 row in set (0.001 sec)
```

```sql
SELECT array_intersect([[1,2,3], [1,2]], [[1,2],[2,3,4]]);
+----------------------------------------------------+
| array_intersect([[1,2,3], [1,2]], [[1,2],[2,3,4]]) |
+----------------------------------------------------+
| [[1,2]]                                            |
+----------------------------------------------------+
1 row in set (0.001 sec)
```

## array_union

`array_union()` 函数用于计算所有输入数组的并集。语法如下：

```sql
array_union(arr_list)
```

输入参数说明如下：

* `arr_list`：需要进行并集运算的数组列表。

返回值为数组类型。

具体说明如下：

* 数组支持嵌套：输入的数组可以是嵌套数组，但要求所有数组的嵌套层数一致，当数组为嵌套数组时，参与运算的元素为第一层数组，即使两个数组的元素相同但顺序不同，也会被视为不同的数组。
* `NULL` 值处理：无特殊处理。

示例如下：

```sql
SELECT array_union([1,2,3], [1,2], [2,3,4]);
+--------------------------------------+
| array_union([1,2,3], [1,2], [2,3,4]) |
+--------------------------------------+
| [1,2,3,4]                            |
+--------------------------------------+
1 row in set (0.001 sec)
```

```sql
SELECT array_union([1,2,3], [4,5,NULL]);
+----------------------------------+
| array_union([1,2,3], [4,5,NULL]) |
+----------------------------------+
| [1,2,3,4,5,NULL]                 |
+----------------------------------+
1 row in set (0.001 sec)
```

```sql
SELECT array_union([[1,2,3], [1,2]], [[1,2],[2,3,4]]);
+------------------------------------------------+
| array_union([[1,2,3], [1,2]], [[1,2],[2,3,4]]) |
+------------------------------------------------+
| [[1,2,3],[1,2],[2,3,4]]                        |
+------------------------------------------------+
1 row in set (0.001 sec)
```
