---

slug: /string-type
---

# STRING 类型

`STRING` 类型作为文本类型的一种，可以更好地支持和迁移 AP 业务，也支持作为主键的不定长字符串。

## 基本功能

* 在创建表时，`STRING` 类型无需指定数据长度，最大可存储的数据长度为 16M（16777216 字节）。

* `STRING` 类型的列（以下简称 String 列）可以作为主键列和索引列，也可以作为 Key/Range columns/List columns 分区类型的分区键。

* `STRING` 类型是一种特殊的 `LOB` 类型：

  * `STRING` 类型是非主键列，当长度超过 `LOB_INROW_THRESHOLD`（`LOB` 列的阈值）时，会溢出到行外存储。
  * `STRING` 类型是主键列，所有数据会行内存储，数据长度会受主键长度的限制。

## 使用限制

* `STRING` 类型的默认值只支持 `NULL`。

* `STRING` 类型做非主键列时，是否溢出行外存储受 `LOB_INROW_THRESHOLD` 的影响。

  有关 `LOB_INROW_THRESHOLD` 的介绍信息，参见 [LOB 类型](400.lob-type.md) 和 [ob_default_lob_inrow_threshold](https://www.oceanbase.com/docs/common-oceanbase-database-cn-1000000002015946)。

* String 列做主键或索引键时，写入（或更新）时会检查主键或索引键长度，超过 16K 会报错。

* 创建包含 String 列的索引时，如果主表上的 String 列已经溢出行外存储，则会报错无法创建索引。

* String 列创建索引之后，如果写入（或更新） String 列的数据，数据需要溢出行外存储（即数据长度大于`LOB_INROW_THRESHOLD`），会报错无法写入/更新数据。

* String 列做分区键时，如果写入（或更新）数据是已经溢出的 LOB，则会报错无法写入（或更新）数据。（例如：`INSERT INTO ... SELECT ...`，`SELECT` 的数据是溢出的）。

* 旁路导入场景中，如果目标表 String 列上存在索引，并且导入数据后在目标表上 String 列需要溢出行外存储（即数据长度大于 `LOB_INROW_THRESHOLD`），会报错无法导入数据。

* 增量旁路导入场景中，如果目标表 String 列上存在索引，源表上对应String 列已经溢出行外存储，则会报错无法导入数据。

## 使用示例

1. 创建表 `test_tbl1`，其中 `col1`、`col2`、`col3` 为 String 列，并且 `col1` 列为主键，表按照 `col1` 的值进行 KEY 分区，分成 4 个分区。

   ```sql
   CREATE TABLE test_tbl1 (col1 STRING PRIMARY KEY,
       col2 STRING,
       col3 STRING,
       col4 VARCHAR(10))
       PARTITION BY KEY(col1) PARTITIONS 4;
   ```

2. String 列 `col2` 上创建索引 `idx_test_tbl1`。

   ```sql
   CREATE INDEX idx_test_tbl1 ON test_tbl1(col2);
   ```

3. 查看表 `test_tbl1` 定义。

   ```sql
   SHOW CREATE TABLE test_tbl1;
   ```

   返回结果如下：

   ```shell
   +-----------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | Table     | Create Table                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
   +-----------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | test_tbl1 | CREATE TABLE `test_tbl1` (
   `col1` string NOT NULL,
   `col2` string DEFAULT NULL,
   `col3` string DEFAULT NULL,
   `col4` varchar(10) DEFAULT NULL,
   PRIMARY KEY (`col1`),
   KEY `idx_test_tbl1` (`col2`) BLOCK_SIZE 16384 LOCAL
   ) ORGANIZATION INDEX DEFAULT CHARSET = utf8mb4 ROW_FORMAT = DYNAMIC COMPRESSION = 'zstd_1.3.8' REPLICA_NUM = 1 BLOCK_SIZE = 16384 USE_BLOOM_FILTER = FALSE ENABLE_MACRO_BLOCK_BLOOM_FILTER = FALSE TABLET_SIZE = 134217728 PCTFREE = 0
   partition by key(col1)
   (partition `p0`,
   partition `p1`,
   partition `p2`,
   partition `p3`) |
   +-----------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   1 row in set
   ```

4. 向表 `test_tbl1` 中插入测试数据。

   ```sql
   INSERT INTO test_tbl1 VALUES("A1", "B1", "C1", "D1"),("A2", "B2", "C2", "D2");
   ```

5. 查看表 `test_tbl1` 中的数据。

   ```sql
   SELECT * FROM test_tbl1;
   ```

   返回结果如下：

   ```shell
   +------+------+------+------+
   | col1 | col2 | col3 | col4 |
   +------+------+------+------+
   | A2   | B2   | C2   | D2   |
   | A1   | B1   | C1   | D1   |
   +------+------+------+------+
   2 rows in set
   ```
