---

slug: /overview-of-pseudo-columns

---

# PARTITIONID 伪列

PARTITIONID 伪列提供了获取每行数据所在分区 id 的能力，PARTITIONID 伪列的值由 `tablescan` 算子读原始数据时直接填值，不会进行实际的存储。本文主要介绍 PARTITIONID 伪列的使用说明。

根据分区级别和功能不同，主要介绍以下六个伪列：

|列名|类型 |含义|
|-------|---------|-----------|
|__ob_partition_id|int|`partition_id`，该行数据对应 `partition` 的 `id`。|
|__ob_partition_index|int|`partition_index`，该行数据对应 `partition` 的序号 `index`。|
|__ob_partition_name|varchar|`partition_name`，该行数据对应 `partition` 的名字 `name`。|
|__ob_sub_partition_id|int|`sub_partition_id`，该行数据对应 `sub_partition` 的 `id`。|
|__ob_sub_partition_index|int|`sub_partition_index`，该行数据对应 `sub_partition` 的序号 `index`。|
|__ob_sub_partition_name|varchar|`sub_partition_name`，该行数据对应 `sub_partition` 的名字 `name`。|

## 基本语法

### SELECT 操作

示例如下：

```sql
select c1,__ob_partition_id from t1;
```

### UPDATE 操作

不允许对 `partitionid` 伪列进行修改，可以出现在 `where` 条件中。

示例如下：

```sql
UPDATE t1 SET c1=c1 WHERE __ob_partition_index=2;
```

## INSERT 操作

不能出现在 `insert` 的 column list 里。

## 限制汇总

### 列名与伪列字段冲突限制

* 查询语句：如果在升级到支持 `partitionid` 版本前有一个表已经有了上述伪列名，那么在查询语句中对于该列仍会返回该列真实的数据；没有的话才会返回对应的伪列值。
* 建表语句：创建表时不允许创建包含有与上述伪列名冲突的列名，否则返回 `OB_ERR_COLUMN_DUPLICATE` 的错误信息。
  * 包括 `create table tt1 as select c1,__ob_partition_id from t1;`。
* Drop column：删除表中某一列时，如果表中已经有了上述伪列名，可以正常删除。否则报错 `OB_ERR_BAD_FIELD_ERROR`。
* Add column：不允许直接 `add` 冲突的 `partitionid` 伪列，否则返回 `OB_ERR_COLUMN_DUPLICATE` 的错误信息。
* Rename column：只允许将现有的与前面伪列名冲突的列名修改成其他的，否则报错 `OB_ERR_COLUMN_DUPLICATE`。

### 表类型限制

只支持用户表和定义时包含了表伪列名的用户视图查询这些伪列。

## 功能开关

`PARTITIONID` 伪列会占用六个列名 `__ob_partition_id`,`__ob_partition_index`，`__ob_partition_name`，`__ob_sub_partition_id`,`__ob_sub_partition_index`,`__ob_sub_partition_name`，导致用户无法再创建包含这些列名的表。

针对此问题可以通过配置项 `_enable_pseudo_partition_id` 来关闭 `PARTITIONID` 伪列功能，当业务需要使用上述的列名来创建表时可以选择关闭。

示例如下：

:::tip

执行下面命令关闭 `partitionid` 伪列功能之后，您需要执行 `ALTER SYSTEM flush plan cache;` 手动清除计划缓存。

:::

```sql
ALTER SYSTEM SET _enable_pseudo_partition_id = false;
```
